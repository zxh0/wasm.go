// Code generated from ./text/grammar/WAST.g4 by ANTLR 4.8. DO NOT EDIT.

package parser // WAST

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 70, 811,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 3, 2, 7, 2, 98,
	10, 2, 12, 2, 14, 2, 101, 11, 2, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 5, 3, 110, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 116, 10, 3, 3, 4, 3,
	4, 3, 4, 3, 4, 5, 4, 122, 10, 4, 3, 4, 3, 4, 7, 4, 126, 10, 4, 12, 4, 14,
	4, 129, 11, 4, 3, 4, 3, 4, 3, 4, 3, 4, 5, 4, 135, 10, 4, 3, 4, 3, 4, 7,
	4, 139, 10, 4, 12, 4, 14, 4, 142, 11, 4, 3, 4, 5, 4, 145, 10, 4, 3, 5,
	3, 5, 3, 5, 5, 5, 150, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	5, 5, 159, 10, 5, 3, 5, 3, 5, 5, 5, 163, 10, 5, 3, 6, 3, 6, 3, 6, 3, 6,
	7, 6, 169, 10, 6, 12, 6, 14, 6, 172, 11, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3,
	6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3,
	6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3,
	6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 212, 10,
	6, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3,
	7, 5, 7, 226, 10, 7, 3, 8, 3, 8, 3, 8, 5, 8, 231, 10, 8, 3, 8, 3, 8, 3,
	8, 3, 8, 3, 8, 3, 8, 5, 8, 239, 10, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 5,
	8, 246, 10, 8, 3, 8, 5, 8, 249, 10, 8, 3, 8, 5, 8, 252, 10, 8, 3, 9, 3,
	9, 3, 9, 3, 10, 3, 10, 3, 10, 5, 10, 260, 10, 10, 3, 10, 7, 10, 263, 10,
	10, 12, 10, 14, 10, 266, 11, 10, 3, 10, 3, 10, 3, 11, 3, 11, 3, 11, 3,
	11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 5, 11, 280, 10, 11, 3, 12,
	3, 12, 3, 12, 5, 12, 285, 10, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3,
	12, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 14, 3, 14, 3, 14,
	5, 14, 303, 10, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 5, 14, 311,
	10, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 5, 14, 319, 10, 14, 3,
	14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 5, 14, 327, 10, 14, 3, 14, 3, 14,
	3, 14, 5, 14, 332, 10, 14, 3, 15, 3, 15, 3, 15, 5, 15, 337, 10, 15, 3,
	15, 3, 15, 3, 15, 7, 15, 342, 10, 15, 12, 15, 14, 15, 345, 11, 15, 3, 15,
	3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 5, 15, 353, 10, 15, 3, 15, 3, 15, 3,
	15, 3, 15, 3, 15, 5, 15, 360, 10, 15, 3, 16, 3, 16, 3, 16, 7, 16, 365,
	10, 16, 12, 16, 14, 16, 368, 11, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
	3, 16, 3, 16, 5, 16, 377, 10, 16, 3, 17, 3, 17, 3, 17, 5, 17, 382, 10,
	17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 5, 17, 391, 10, 17,
	3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 5, 17, 401, 10,
	17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 5, 17, 411,
	10, 17, 3, 18, 3, 18, 3, 18, 5, 18, 416, 10, 18, 3, 18, 3, 18, 3, 18, 3,
	18, 3, 18, 3, 18, 3, 18, 5, 18, 425, 10, 18, 3, 18, 3, 18, 3, 18, 3, 18,
	3, 18, 3, 18, 3, 18, 3, 18, 5, 18, 435, 10, 18, 3, 18, 3, 18, 3, 18, 3,
	18, 7, 18, 441, 10, 18, 12, 18, 14, 18, 444, 11, 18, 3, 18, 3, 18, 3, 18,
	5, 18, 449, 10, 18, 3, 19, 3, 19, 3, 19, 5, 19, 454, 10, 19, 3, 19, 3,
	19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 5, 19, 464, 10, 19, 3, 19,
	3, 19, 3, 19, 3, 19, 3, 19, 5, 19, 471, 10, 19, 3, 20, 3, 20, 3, 20, 3,
	20, 3, 20, 3, 20, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21,
	3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3,
	21, 3, 21, 5, 21, 499, 10, 21, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 23,
	3, 23, 3, 23, 5, 23, 509, 10, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3,
	23, 3, 23, 3, 23, 3, 23, 3, 23, 5, 23, 521, 10, 23, 3, 23, 3, 23, 3, 23,
	3, 23, 5, 23, 527, 10, 23, 3, 24, 3, 24, 3, 24, 5, 24, 532, 10, 24, 3,
	24, 3, 24, 3, 24, 3, 24, 3, 24, 7, 24, 539, 10, 24, 12, 24, 14, 24, 542,
	11, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 549, 10, 24, 3, 24, 3,
	24, 7, 24, 553, 10, 24, 12, 24, 14, 24, 556, 11, 24, 3, 24, 3, 24, 5, 24,
	560, 10, 24, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 26, 3, 26, 3,
	26, 3, 26, 7, 26, 572, 10, 26, 12, 26, 14, 26, 575, 11, 26, 3, 27, 3, 27,
	3, 27, 3, 27, 3, 27, 5, 27, 582, 10, 27, 3, 27, 3, 27, 3, 28, 7, 28, 587,
	10, 28, 12, 28, 14, 28, 590, 11, 28, 3, 29, 3, 29, 3, 30, 5, 30, 595, 10,
	30, 3, 30, 5, 30, 598, 10, 30, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31,
	5, 31, 606, 10, 31, 3, 32, 3, 32, 3, 33, 3, 33, 3, 33, 3, 34, 3, 34, 3,
	35, 3, 35, 5, 35, 617, 10, 35, 3, 36, 7, 36, 620, 10, 36, 12, 36, 14, 36,
	623, 11, 36, 3, 36, 7, 36, 626, 10, 36, 12, 36, 14, 36, 629, 11, 36, 3,
	37, 3, 37, 3, 37, 7, 37, 634, 10, 37, 12, 37, 14, 37, 637, 11, 37, 3, 37,
	3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 5, 37, 646, 10, 37, 3, 38, 3,
	38, 3, 38, 7, 38, 651, 10, 38, 12, 38, 14, 38, 654, 11, 38, 3, 38, 3, 38,
	3, 39, 7, 39, 659, 10, 39, 12, 39, 14, 39, 662, 11, 39, 3, 40, 3, 40, 3,
	40, 5, 40, 667, 10, 40, 3, 41, 3, 41, 3, 41, 7, 41, 672, 10, 41, 12, 41,
	14, 41, 675, 11, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 682, 10,
	41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 691, 10, 41,
	3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 700, 10, 41, 3,
	41, 3, 41, 7, 41, 704, 10, 41, 12, 41, 14, 41, 707, 11, 41, 3, 41, 3, 41,
	3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 718, 10, 41, 3,
	41, 3, 41, 5, 41, 722, 10, 41, 3, 42, 3, 42, 5, 42, 726, 10, 42, 3, 42,
	3, 42, 3, 42, 3, 42, 5, 42, 732, 10, 42, 3, 42, 3, 42, 5, 42, 736, 10,
	42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 742, 10, 42, 3, 42, 3, 42, 5, 42,
	746, 10, 42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 752, 10, 42, 3, 42, 5,
	42, 755, 10, 42, 3, 42, 3, 42, 5, 42, 759, 10, 42, 5, 42, 761, 10, 42,
	3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 6, 43, 771, 10,
	43, 13, 43, 14, 43, 772, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43,
	3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 5, 43, 790, 10,
	43, 3, 44, 3, 44, 3, 44, 3, 45, 3, 45, 3, 45, 5, 45, 798, 10, 45, 3, 45,
	3, 45, 3, 45, 5, 45, 803, 10, 45, 3, 46, 3, 46, 3, 47, 3, 47, 3, 48, 3,
	48, 3, 48, 2, 2, 49, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28,
	30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64,
	66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 2, 4, 3, 2,
	61, 63, 4, 2, 59, 59, 62, 62, 2, 895, 2, 99, 3, 2, 2, 2, 4, 115, 3, 2,
	2, 2, 6, 144, 3, 2, 2, 2, 8, 162, 3, 2, 2, 2, 10, 211, 3, 2, 2, 2, 12,
	225, 3, 2, 2, 2, 14, 251, 3, 2, 2, 2, 16, 253, 3, 2, 2, 2, 18, 256, 3,
	2, 2, 2, 20, 279, 3, 2, 2, 2, 22, 281, 3, 2, 2, 2, 24, 292, 3, 2, 2, 2,
	26, 331, 3, 2, 2, 2, 28, 359, 3, 2, 2, 2, 30, 376, 3, 2, 2, 2, 32, 410,
	3, 2, 2, 2, 34, 448, 3, 2, 2, 2, 36, 470, 3, 2, 2, 2, 38, 472, 3, 2, 2,
	2, 40, 498, 3, 2, 2, 2, 42, 500, 3, 2, 2, 2, 44, 526, 3, 2, 2, 2, 46, 559,
	3, 2, 2, 2, 48, 561, 3, 2, 2, 2, 50, 573, 3, 2, 2, 2, 52, 581, 3, 2, 2,
	2, 54, 588, 3, 2, 2, 2, 56, 591, 3, 2, 2, 2, 58, 597, 3, 2, 2, 2, 60, 605,
	3, 2, 2, 2, 62, 607, 3, 2, 2, 2, 64, 609, 3, 2, 2, 2, 66, 612, 3, 2, 2,
	2, 68, 614, 3, 2, 2, 2, 70, 621, 3, 2, 2, 2, 72, 645, 3, 2, 2, 2, 74, 647,
	3, 2, 2, 2, 76, 660, 3, 2, 2, 2, 78, 666, 3, 2, 2, 2, 80, 721, 3, 2, 2,
	2, 82, 760, 3, 2, 2, 2, 84, 789, 3, 2, 2, 2, 86, 791, 3, 2, 2, 2, 88, 797,
	3, 2, 2, 2, 90, 804, 3, 2, 2, 2, 92, 806, 3, 2, 2, 2, 94, 808, 3, 2, 2,
	2, 96, 98, 5, 4, 3, 2, 97, 96, 3, 2, 2, 2, 98, 101, 3, 2, 2, 2, 99, 97,
	3, 2, 2, 2, 99, 100, 3, 2, 2, 2, 100, 102, 3, 2, 2, 2, 101, 99, 3, 2, 2,
	2, 102, 103, 7, 2, 2, 3, 103, 3, 3, 2, 2, 2, 104, 116, 5, 6, 4, 2, 105,
	106, 7, 3, 2, 2, 106, 107, 7, 4, 2, 2, 107, 109, 7, 60, 2, 2, 108, 110,
	7, 59, 2, 2, 109, 108, 3, 2, 2, 2, 109, 110, 3, 2, 2, 2, 110, 111, 3, 2,
	2, 2, 111, 116, 7, 5, 2, 2, 112, 116, 5, 8, 5, 2, 113, 116, 5, 10, 6, 2,
	114, 116, 5, 14, 8, 2, 115, 104, 3, 2, 2, 2, 115, 105, 3, 2, 2, 2, 115,
	112, 3, 2, 2, 2, 115, 113, 3, 2, 2, 2, 115, 114, 3, 2, 2, 2, 116, 5, 3,
	2, 2, 2, 117, 145, 5, 18, 10, 2, 118, 119, 7, 3, 2, 2, 119, 121, 7, 6,
	2, 2, 120, 122, 7, 59, 2, 2, 121, 120, 3, 2, 2, 2, 121, 122, 3, 2, 2, 2,
	122, 123, 3, 2, 2, 2, 123, 127, 7, 7, 2, 2, 124, 126, 7, 60, 2, 2, 125,
	124, 3, 2, 2, 2, 126, 129, 3, 2, 2, 2, 127, 125, 3, 2, 2, 2, 127, 128,
	3, 2, 2, 2, 128, 130, 3, 2, 2, 2, 129, 127, 3, 2, 2, 2, 130, 145, 7, 5,
	2, 2, 131, 132, 7, 3, 2, 2, 132, 134, 7, 6, 2, 2, 133, 135, 7, 59, 2, 2,
	134, 133, 3, 2, 2, 2, 134, 135, 3, 2, 2, 2, 135, 136, 3, 2, 2, 2, 136,
	140, 7, 8, 2, 2, 137, 139, 7, 60, 2, 2, 138, 137, 3, 2, 2, 2, 139, 142,
	3, 2, 2, 2, 140, 138, 3, 2, 2, 2, 140, 141, 3, 2, 2, 2, 141, 143, 3, 2,
	2, 2, 142, 140, 3, 2, 2, 2, 143, 145, 7, 5, 2, 2, 144, 117, 3, 2, 2, 2,
	144, 118, 3, 2, 2, 2, 144, 131, 3, 2, 2, 2, 145, 7, 3, 2, 2, 2, 146, 147,
	7, 3, 2, 2, 147, 149, 7, 9, 2, 2, 148, 150, 7, 59, 2, 2, 149, 148, 3, 2,
	2, 2, 149, 150, 3, 2, 2, 2, 150, 151, 3, 2, 2, 2, 151, 152, 7, 60, 2, 2,
	152, 153, 5, 76, 39, 2, 153, 154, 7, 5, 2, 2, 154, 163, 3, 2, 2, 2, 155,
	156, 7, 3, 2, 2, 156, 158, 7, 10, 2, 2, 157, 159, 7, 59, 2, 2, 158, 157,
	3, 2, 2, 2, 158, 159, 3, 2, 2, 2, 159, 160, 3, 2, 2, 2, 160, 161, 7, 60,
	2, 2, 161, 163, 7, 5, 2, 2, 162, 146, 3, 2, 2, 2, 162, 155, 3, 2, 2, 2,
	163, 9, 3, 2, 2, 2, 164, 165, 7, 3, 2, 2, 165, 166, 7, 11, 2, 2, 166, 170,
	5, 8, 5, 2, 167, 169, 5, 12, 7, 2, 168, 167, 3, 2, 2, 2, 169, 172, 3, 2,
	2, 2, 170, 168, 3, 2, 2, 2, 170, 171, 3, 2, 2, 2, 171, 173, 3, 2, 2, 2,
	172, 170, 3, 2, 2, 2, 173, 174, 7, 5, 2, 2, 174, 212, 3, 2, 2, 2, 175,
	176, 7, 3, 2, 2, 176, 177, 7, 12, 2, 2, 177, 178, 5, 8, 5, 2, 178, 179,
	7, 60, 2, 2, 179, 180, 7, 5, 2, 2, 180, 212, 3, 2, 2, 2, 181, 182, 7, 3,
	2, 2, 182, 183, 7, 13, 2, 2, 183, 184, 5, 8, 5, 2, 184, 185, 7, 60, 2,
	2, 185, 186, 7, 5, 2, 2, 186, 212, 3, 2, 2, 2, 187, 188, 7, 3, 2, 2, 188,
	189, 7, 14, 2, 2, 189, 190, 5, 6, 4, 2, 190, 191, 7, 60, 2, 2, 191, 192,
	7, 5, 2, 2, 192, 212, 3, 2, 2, 2, 193, 194, 7, 3, 2, 2, 194, 195, 7, 15,
	2, 2, 195, 196, 5, 6, 4, 2, 196, 197, 7, 60, 2, 2, 197, 198, 7, 5, 2, 2,
	198, 212, 3, 2, 2, 2, 199, 200, 7, 3, 2, 2, 200, 201, 7, 16, 2, 2, 201,
	202, 5, 6, 4, 2, 202, 203, 7, 60, 2, 2, 203, 204, 7, 5, 2, 2, 204, 212,
	3, 2, 2, 2, 205, 206, 7, 3, 2, 2, 206, 207, 7, 12, 2, 2, 207, 208, 5, 6,
	4, 2, 208, 209, 7, 60, 2, 2, 209, 210, 7, 5, 2, 2, 210, 212, 3, 2, 2, 2,
	211, 164, 3, 2, 2, 2, 211, 175, 3, 2, 2, 2, 211, 181, 3, 2, 2, 2, 211,
	187, 3, 2, 2, 2, 211, 193, 3, 2, 2, 2, 211, 199, 3, 2, 2, 2, 211, 205,
	3, 2, 2, 2, 212, 11, 3, 2, 2, 2, 213, 214, 7, 3, 2, 2, 214, 215, 5, 86,
	44, 2, 215, 216, 7, 5, 2, 2, 216, 226, 3, 2, 2, 2, 217, 218, 7, 3, 2, 2,
	218, 219, 7, 66, 2, 2, 219, 220, 7, 17, 2, 2, 220, 226, 7, 5, 2, 2, 221,
	222, 7, 3, 2, 2, 222, 223, 7, 66, 2, 2, 223, 224, 7, 18, 2, 2, 224, 226,
	7, 5, 2, 2, 225, 213, 3, 2, 2, 2, 225, 217, 3, 2, 2, 2, 225, 221, 3, 2,
	2, 2, 226, 13, 3, 2, 2, 2, 227, 228, 7, 3, 2, 2, 228, 230, 7, 19, 2, 2,
	229, 231, 7, 59, 2, 2, 230, 229, 3, 2, 2, 2, 230, 231, 3, 2, 2, 2, 231,
	232, 3, 2, 2, 2, 232, 233, 5, 2, 2, 2, 233, 234, 7, 5, 2, 2, 234, 252,
	3, 2, 2, 2, 235, 236, 7, 3, 2, 2, 236, 238, 7, 20, 2, 2, 237, 239, 7, 59,
	2, 2, 238, 237, 3, 2, 2, 2, 238, 239, 3, 2, 2, 2, 239, 240, 3, 2, 2, 2,
	240, 241, 7, 60, 2, 2, 241, 252, 7, 5, 2, 2, 242, 243, 7, 3, 2, 2, 243,
	245, 7, 21, 2, 2, 244, 246, 7, 59, 2, 2, 245, 244, 3, 2, 2, 2, 245, 246,
	3, 2, 2, 2, 246, 248, 3, 2, 2, 2, 247, 249, 7, 60, 2, 2, 248, 247, 3, 2,
	2, 2, 248, 249, 3, 2, 2, 2, 249, 250, 3, 2, 2, 2, 250, 252, 7, 5, 2, 2,
	251, 227, 3, 2, 2, 2, 251, 235, 3, 2, 2, 2, 251, 242, 3, 2, 2, 2, 252,
	15, 3, 2, 2, 2, 253, 254, 5, 18, 10, 2, 254, 255, 7, 2, 2, 3, 255, 17,
	3, 2, 2, 2, 256, 257, 7, 3, 2, 2, 257, 259, 7, 6, 2, 2, 258, 260, 7, 59,
	2, 2, 259, 258, 3, 2, 2, 2, 259, 260, 3, 2, 2, 2, 260, 264, 3, 2, 2, 2,
	261, 263, 5, 20, 11, 2, 262, 261, 3, 2, 2, 2, 263, 266, 3, 2, 2, 2, 264,
	262, 3, 2, 2, 2, 264, 265, 3, 2, 2, 2, 265, 267, 3, 2, 2, 2, 266, 264,
	3, 2, 2, 2, 267, 268, 7, 5, 2, 2, 268, 19, 3, 2, 2, 2, 269, 280, 5, 22,
	12, 2, 270, 280, 5, 24, 13, 2, 271, 280, 5, 28, 15, 2, 272, 280, 5, 32,
	17, 2, 273, 280, 5, 34, 18, 2, 274, 280, 5, 36, 19, 2, 275, 280, 5, 38,
	20, 2, 276, 280, 5, 42, 22, 2, 277, 280, 5, 44, 23, 2, 278, 280, 5, 46,
	24, 2, 279, 269, 3, 2, 2, 2, 279, 270, 3, 2, 2, 2, 279, 271, 3, 2, 2, 2,
	279, 272, 3, 2, 2, 2, 279, 273, 3, 2, 2, 2, 279, 274, 3, 2, 2, 2, 279,
	275, 3, 2, 2, 2, 279, 276, 3, 2, 2, 2, 279, 277, 3, 2, 2, 2, 279, 278,
	3, 2, 2, 2, 280, 21, 3, 2, 2, 2, 281, 282, 7, 3, 2, 2, 282, 284, 7, 22,
	2, 2, 283, 285, 7, 59, 2, 2, 284, 283, 3, 2, 2, 2, 284, 285, 3, 2, 2, 2,
	285, 286, 3, 2, 2, 2, 286, 287, 7, 3, 2, 2, 287, 288, 7, 23, 2, 2, 288,
	289, 5, 70, 36, 2, 289, 290, 7, 5, 2, 2, 290, 291, 7, 5, 2, 2, 291, 23,
	3, 2, 2, 2, 292, 293, 7, 3, 2, 2, 293, 294, 7, 24, 2, 2, 294, 295, 7, 60,
	2, 2, 295, 296, 7, 60, 2, 2, 296, 297, 5, 26, 14, 2, 297, 298, 7, 5, 2,
	2, 298, 25, 3, 2, 2, 2, 299, 300, 7, 3, 2, 2, 300, 302, 7, 23, 2, 2, 301,
	303, 7, 59, 2, 2, 302, 301, 3, 2, 2, 2, 302, 303, 3, 2, 2, 2, 303, 304,
	3, 2, 2, 2, 304, 305, 5, 52, 27, 2, 305, 306, 7, 5, 2, 2, 306, 332, 3,
	2, 2, 2, 307, 308, 7, 3, 2, 2, 308, 310, 7, 25, 2, 2, 309, 311, 7, 59,
	2, 2, 310, 309, 3, 2, 2, 2, 310, 311, 3, 2, 2, 2, 311, 312, 3, 2, 2, 2,
	312, 313, 5, 64, 33, 2, 313, 314, 7, 5, 2, 2, 314, 332, 3, 2, 2, 2, 315,
	316, 7, 3, 2, 2, 316, 318, 7, 26, 2, 2, 317, 319, 7, 59, 2, 2, 318, 317,
	3, 2, 2, 2, 318, 319, 3, 2, 2, 2, 319, 320, 3, 2, 2, 2, 320, 321, 5, 62,
	32, 2, 321, 322, 7, 5, 2, 2, 322, 332, 3, 2, 2, 2, 323, 324, 7, 3, 2, 2,
	324, 326, 7, 27, 2, 2, 325, 327, 7, 59, 2, 2, 326, 325, 3, 2, 2, 2, 326,
	327, 3, 2, 2, 2, 327, 328, 3, 2, 2, 2, 328, 329, 5, 60, 31, 2, 329, 330,
	7, 5, 2, 2, 330, 332, 3, 2, 2, 2, 331, 299, 3, 2, 2, 2, 331, 307, 3, 2,
	2, 2, 331, 315, 3, 2, 2, 2, 331, 323, 3, 2, 2, 2, 332, 27, 3, 2, 2, 2,
	333, 334, 7, 3, 2, 2, 334, 336, 7, 23, 2, 2, 335, 337, 7, 59, 2, 2, 336,
	335, 3, 2, 2, 2, 336, 337, 3, 2, 2, 2, 337, 338, 3, 2, 2, 2, 338, 339,
	5, 50, 26, 2, 339, 343, 5, 52, 27, 2, 340, 342, 5, 30, 16, 2, 341, 340,
	3, 2, 2, 2, 342, 345, 3, 2, 2, 2, 343, 341, 3, 2, 2, 2, 343, 344, 3, 2,
	2, 2, 344, 346, 3, 2, 2, 2, 345, 343, 3, 2, 2, 2, 346, 347, 5, 76, 39,
	2, 347, 348, 7, 5, 2, 2, 348, 360, 3, 2, 2, 2, 349, 350, 7, 3, 2, 2, 350,
	352, 7, 23, 2, 2, 351, 353, 7, 59, 2, 2, 352, 351, 3, 2, 2, 2, 352, 353,
	3, 2, 2, 2, 353, 354, 3, 2, 2, 2, 354, 355, 5, 50, 26, 2, 355, 356, 5,
	48, 25, 2, 356, 357, 5, 52, 27, 2, 357, 358, 7, 5, 2, 2, 358, 360, 3, 2,
	2, 2, 359, 333, 3, 2, 2, 2, 359, 349, 3, 2, 2, 2, 360, 29, 3, 2, 2, 2,
	361, 362, 7, 3, 2, 2, 362, 366, 7, 28, 2, 2, 363, 365, 5, 56, 29, 2, 364,
	363, 3, 2, 2, 2, 365, 368, 3, 2, 2, 2, 366, 364, 3, 2, 2, 2, 366, 367,
	3, 2, 2, 2, 367, 369, 3, 2, 2, 2, 368, 366, 3, 2, 2, 2, 369, 377, 7, 5,
	2, 2, 370, 371, 7, 3, 2, 2, 371, 372, 7, 28, 2, 2, 372, 373, 7, 59, 2,
	2, 373, 374, 5, 56, 29, 2, 374, 375, 7, 5, 2, 2, 375, 377, 3, 2, 2, 2,
	376, 361, 3, 2, 2, 2, 376, 370, 3, 2, 2, 2, 377, 31, 3, 2, 2, 2, 378, 379,
	7, 3, 2, 2, 379, 381, 7, 25, 2, 2, 380, 382, 7, 59, 2, 2, 381, 380, 3,
	2, 2, 2, 381, 382, 3, 2, 2, 2, 382, 383, 3, 2, 2, 2, 383, 384, 5, 50, 26,
	2, 384, 385, 5, 64, 33, 2, 385, 386, 7, 5, 2, 2, 386, 411, 3, 2, 2, 2,
	387, 388, 7, 3, 2, 2, 388, 390, 7, 25, 2, 2, 389, 391, 7, 59, 2, 2, 390,
	389, 3, 2, 2, 2, 390, 391, 3, 2, 2, 2, 391, 392, 3, 2, 2, 2, 392, 393,
	5, 50, 26, 2, 393, 394, 5, 48, 25, 2, 394, 395, 5, 64, 33, 2, 395, 396,
	7, 5, 2, 2, 396, 411, 3, 2, 2, 2, 397, 398, 7, 3, 2, 2, 398, 400, 7, 25,
	2, 2, 399, 401, 7, 59, 2, 2, 400, 399, 3, 2, 2, 2, 400, 401, 3, 2, 2, 2,
	401, 402, 3, 2, 2, 2, 402, 403, 5, 50, 26, 2, 403, 404, 5, 66, 34, 2, 404,
	405, 7, 3, 2, 2, 405, 406, 7, 29, 2, 2, 406, 407, 5, 54, 28, 2, 407, 408,
	7, 5, 2, 2, 408, 409, 7, 5, 2, 2, 409, 411, 3, 2, 2, 2, 410, 378, 3, 2,
	2, 2, 410, 387, 3, 2, 2, 2, 410, 397, 3, 2, 2, 2, 411, 33, 3, 2, 2, 2,
	412, 413, 7, 3, 2, 2, 413, 415, 7, 26, 2, 2, 414, 416, 7, 59, 2, 2, 415,
	414, 3, 2, 2, 2, 415, 416, 3, 2, 2, 2, 416, 417, 3, 2, 2, 2, 417, 418,
	5, 50, 26, 2, 418, 419, 5, 62, 32, 2, 419, 420, 7, 5, 2, 2, 420, 449, 3,
	2, 2, 2, 421, 422, 7, 3, 2, 2, 422, 424, 7, 26, 2, 2, 423, 425, 7, 59,
	2, 2, 424, 423, 3, 2, 2, 2, 424, 425, 3, 2, 2, 2, 425, 426, 3, 2, 2, 2,
	426, 427, 5, 50, 26, 2, 427, 428, 5, 48, 25, 2, 428, 429, 5, 62, 32, 2,
	429, 430, 7, 5, 2, 2, 430, 449, 3, 2, 2, 2, 431, 432, 7, 3, 2, 2, 432,
	434, 7, 26, 2, 2, 433, 435, 7, 59, 2, 2, 434, 433, 3, 2, 2, 2, 434, 435,
	3, 2, 2, 2, 435, 436, 3, 2, 2, 2, 436, 437, 5, 50, 26, 2, 437, 438, 7,
	3, 2, 2, 438, 442, 7, 30, 2, 2, 439, 441, 7, 60, 2, 2, 440, 439, 3, 2,
	2, 2, 441, 444, 3, 2, 2, 2, 442, 440, 3, 2, 2, 2, 442, 443, 3, 2, 2, 2,
	443, 445, 3, 2, 2, 2, 444, 442, 3, 2, 2, 2, 445, 446, 7, 5, 2, 2, 446,
	447, 7, 5, 2, 2, 447, 449, 3, 2, 2, 2, 448, 412, 3, 2, 2, 2, 448, 421,
	3, 2, 2, 2, 448, 431, 3, 2, 2, 2, 449, 35, 3, 2, 2, 2, 450, 451, 7, 3,
	2, 2, 451, 453, 7, 27, 2, 2, 452, 454, 7, 59, 2, 2, 453, 452, 3, 2, 2,
	2, 453, 454, 3, 2, 2, 2, 454, 455, 3, 2, 2, 2, 455, 456, 5, 50, 26, 2,
	456, 457, 5, 60, 31, 2, 457, 458, 5, 76, 39, 2, 458, 459, 7, 5, 2, 2, 459,
	471, 3, 2, 2, 2, 460, 461, 7, 3, 2, 2, 461, 463, 7, 27, 2, 2, 462, 464,
	7, 59, 2, 2, 463, 462, 3, 2, 2, 2, 463, 464, 3, 2, 2, 2, 464, 465, 3, 2,
	2, 2, 465, 466, 5, 50, 26, 2, 466, 467, 5, 48, 25, 2, 467, 468, 5, 60,
	31, 2, 468, 469, 7, 5, 2, 2, 469, 471, 3, 2, 2, 2, 470, 450, 3, 2, 2, 2,
	470, 460, 3, 2, 2, 2, 471, 37, 3, 2, 2, 2, 472, 473, 7, 3, 2, 2, 473, 474,
	7, 31, 2, 2, 474, 475, 7, 60, 2, 2, 475, 476, 5, 40, 21, 2, 476, 477, 7,
	5, 2, 2, 477, 39, 3, 2, 2, 2, 478, 479, 7, 3, 2, 2, 479, 480, 7, 23, 2,
	2, 480, 481, 5, 94, 48, 2, 481, 482, 7, 5, 2, 2, 482, 499, 3, 2, 2, 2,
	483, 484, 7, 3, 2, 2, 484, 485, 7, 25, 2, 2, 485, 486, 5, 94, 48, 2, 486,
	487, 7, 5, 2, 2, 487, 499, 3, 2, 2, 2, 488, 489, 7, 3, 2, 2, 489, 490,
	7, 26, 2, 2, 490, 491, 5, 94, 48, 2, 491, 492, 7, 5, 2, 2, 492, 499, 3,
	2, 2, 2, 493, 494, 7, 3, 2, 2, 494, 495, 7, 27, 2, 2, 495, 496, 5, 94,
	48, 2, 496, 497, 7, 5, 2, 2, 497, 499, 3, 2, 2, 2, 498, 478, 3, 2, 2, 2,
	498, 483, 3, 2, 2, 2, 498, 488, 3, 2, 2, 2, 498, 493, 3, 2, 2, 2, 499,
	41, 3, 2, 2, 2, 500, 501, 7, 3, 2, 2, 501, 502, 7, 32, 2, 2, 502, 503,
	5, 94, 48, 2, 503, 504, 7, 5, 2, 2, 504, 43, 3, 2, 2, 2, 505, 506, 7, 3,
	2, 2, 506, 508, 7, 29, 2, 2, 507, 509, 5, 94, 48, 2, 508, 507, 3, 2, 2,
	2, 508, 509, 3, 2, 2, 2, 509, 510, 3, 2, 2, 2, 510, 511, 7, 3, 2, 2, 511,
	512, 7, 33, 2, 2, 512, 513, 5, 76, 39, 2, 513, 514, 7, 5, 2, 2, 514, 515,
	5, 54, 28, 2, 515, 516, 7, 5, 2, 2, 516, 527, 3, 2, 2, 2, 517, 518, 7,
	3, 2, 2, 518, 520, 7, 29, 2, 2, 519, 521, 5, 94, 48, 2, 520, 519, 3, 2,
	2, 2, 520, 521, 3, 2, 2, 2, 521, 522, 3, 2, 2, 2, 522, 523, 5, 76, 39,
	2, 523, 524, 5, 54, 28, 2, 524, 525, 7, 5, 2, 2, 525, 527, 3, 2, 2, 2,
	526, 505, 3, 2, 2, 2, 526, 517, 3, 2, 2, 2, 527, 45, 3, 2, 2, 2, 528, 529,
	7, 3, 2, 2, 529, 531, 7, 30, 2, 2, 530, 532, 5, 94, 48, 2, 531, 530, 3,
	2, 2, 2, 531, 532, 3, 2, 2, 2, 532, 533, 3, 2, 2, 2, 533, 534, 7, 3, 2,
	2, 534, 535, 7, 33, 2, 2, 535, 536, 5, 76, 39, 2, 536, 540, 7, 5, 2, 2,
	537, 539, 7, 60, 2, 2, 538, 537, 3, 2, 2, 2, 539, 542, 3, 2, 2, 2, 540,
	538, 3, 2, 2, 2, 540, 541, 3, 2, 2, 2, 541, 543, 3, 2, 2, 2, 542, 540,
	3, 2, 2, 2, 543, 544, 7, 5, 2, 2, 544, 560, 3, 2, 2, 2, 545, 546, 7, 3,
	2, 2, 546, 548, 7, 30, 2, 2, 547, 549, 5, 94, 48, 2, 548, 547, 3, 2, 2,
	2, 548, 549, 3, 2, 2, 2, 549, 550, 3, 2, 2, 2, 550, 554, 5, 76, 39, 2,
	551, 553, 7, 60, 2, 2, 552, 551, 3, 2, 2, 2, 553, 556, 3, 2, 2, 2, 554,
	552, 3, 2, 2, 2, 554, 555, 3, 2, 2, 2, 555, 557, 3, 2, 2, 2, 556, 554,
	3, 2, 2, 2, 557, 558, 7, 5, 2, 2, 558, 560, 3, 2, 2, 2, 559, 528, 3, 2,
	2, 2, 559, 545, 3, 2, 2, 2, 560, 47, 3, 2, 2, 2, 561, 562, 7, 3, 2, 2,
	562, 563, 7, 24, 2, 2, 563, 564, 7, 60, 2, 2, 564, 565, 7, 60, 2, 2, 565,
	566, 7, 5, 2, 2, 566, 49, 3, 2, 2, 2, 567, 568, 7, 3, 2, 2, 568, 569, 7,
	31, 2, 2, 569, 570, 7, 60, 2, 2, 570, 572, 7, 5, 2, 2, 571, 567, 3, 2,
	2, 2, 572, 575, 3, 2, 2, 2, 573, 571, 3, 2, 2, 2, 573, 574, 3, 2, 2, 2,
	574, 51, 3, 2, 2, 2, 575, 573, 3, 2, 2, 2, 576, 577, 7, 3, 2, 2, 577, 578,
	7, 22, 2, 2, 578, 579, 5, 94, 48, 2, 579, 580, 7, 5, 2, 2, 580, 582, 3,
	2, 2, 2, 581, 576, 3, 2, 2, 2, 581, 582, 3, 2, 2, 2, 582, 583, 3, 2, 2,
	2, 583, 584, 5, 70, 36, 2, 584, 53, 3, 2, 2, 2, 585, 587, 5, 94, 48, 2,
	586, 585, 3, 2, 2, 2, 587, 590, 3, 2, 2, 2, 588, 586, 3, 2, 2, 2, 588,
	589, 3, 2, 2, 2, 589, 55, 3, 2, 2, 2, 590, 588, 3, 2, 2, 2, 591, 592, 7,
	58, 2, 2, 592, 57, 3, 2, 2, 2, 593, 595, 5, 74, 38, 2, 594, 593, 3, 2,
	2, 2, 594, 595, 3, 2, 2, 2, 595, 598, 3, 2, 2, 2, 596, 598, 5, 52, 27,
	2, 597, 594, 3, 2, 2, 2, 597, 596, 3, 2, 2, 2, 598, 59, 3, 2, 2, 2, 599,
	606, 5, 56, 29, 2, 600, 601, 7, 3, 2, 2, 601, 602, 7, 34, 2, 2, 602, 603,
	5, 56, 29, 2, 603, 604, 7, 5, 2, 2, 604, 606, 3, 2, 2, 2, 605, 599, 3,
	2, 2, 2, 605, 600, 3, 2, 2, 2, 606, 61, 3, 2, 2, 2, 607, 608, 5, 68, 35,
	2, 608, 63, 3, 2, 2, 2, 609, 610, 5, 68, 35, 2, 610, 611, 5, 66, 34, 2,
	611, 65, 3, 2, 2, 2, 612, 613, 7, 35, 2, 2, 613, 67, 3, 2, 2, 2, 614, 616,
	5, 90, 46, 2, 615, 617, 5, 90, 46, 2, 616, 615, 3, 2, 2, 2, 616, 617, 3,
	2, 2, 2, 617, 69, 3, 2, 2, 2, 618, 620, 5, 72, 37, 2, 619, 618, 3, 2, 2,
	2, 620, 623, 3, 2, 2, 2, 621, 619, 3, 2, 2, 2, 621, 622, 3, 2, 2, 2, 622,
	627, 3, 2, 2, 2, 623, 621, 3, 2, 2, 2, 624, 626, 5, 74, 38, 2, 625, 624,
	3, 2, 2, 2, 626, 629, 3, 2, 2, 2, 627, 625, 3, 2, 2, 2, 627, 628, 3, 2,
	2, 2, 628, 71, 3, 2, 2, 2, 629, 627, 3, 2, 2, 2, 630, 631, 7, 3, 2, 2,
	631, 635, 7, 36, 2, 2, 632, 634, 5, 56, 29, 2, 633, 632, 3, 2, 2, 2, 634,
	637, 3, 2, 2, 2, 635, 633, 3, 2, 2, 2, 635, 636, 3, 2, 2, 2, 636, 638,
	3, 2, 2, 2, 637, 635, 3, 2, 2, 2, 638, 646, 7, 5, 2, 2, 639, 640, 7, 3,
	2, 2, 640, 641, 7, 36, 2, 2, 641, 642, 7, 59, 2, 2, 642, 643, 5, 56, 29,
	2, 643, 644, 7, 5, 2, 2, 644, 646, 3, 2, 2, 2, 645, 630, 3, 2, 2, 2, 645,
	639, 3, 2, 2, 2, 646, 73, 3, 2, 2, 2, 647, 648, 7, 3, 2, 2, 648, 652, 7,
	37, 2, 2, 649, 651, 5, 56, 29, 2, 650, 649, 3, 2, 2, 2, 651, 654, 3, 2,
	2, 2, 652, 650, 3, 2, 2, 2, 652, 653, 3, 2, 2, 2, 653, 655, 3, 2, 2, 2,
	654, 652, 3, 2, 2, 2, 655, 656, 7, 5, 2, 2, 656, 75, 3, 2, 2, 2, 657, 659,
	5, 78, 40, 2, 658, 657, 3, 2, 2, 2, 659, 662, 3, 2, 2, 2, 660, 658, 3,
	2, 2, 2, 660, 661, 3, 2, 2, 2, 661, 77, 3, 2, 2, 2, 662, 660, 3, 2, 2,
	2, 663, 667, 5, 84, 43, 2, 664, 667, 5, 82, 42, 2, 665, 667, 5, 80, 41,
	2, 666, 663, 3, 2, 2, 2, 666, 664, 3, 2, 2, 2, 666, 665, 3, 2, 2, 2, 667,
	79, 3, 2, 2, 2, 668, 669, 7, 3, 2, 2, 669, 673, 5, 84, 43, 2, 670, 672,
	5, 80, 41, 2, 671, 670, 3, 2, 2, 2, 672, 675, 3, 2, 2, 2, 673, 671, 3,
	2, 2, 2, 673, 674, 3, 2, 2, 2, 674, 676, 3, 2, 2, 2, 675, 673, 3, 2, 2,
	2, 676, 677, 7, 5, 2, 2, 677, 722, 3, 2, 2, 2, 678, 679, 7, 3, 2, 2, 679,
	681, 7, 38, 2, 2, 680, 682, 7, 59, 2, 2, 681, 680, 3, 2, 2, 2, 681, 682,
	3, 2, 2, 2, 682, 683, 3, 2, 2, 2, 683, 684, 5, 58, 30, 2, 684, 685, 5,
	76, 39, 2, 685, 686, 7, 5, 2, 2, 686, 722, 3, 2, 2, 2, 687, 688, 7, 3,
	2, 2, 688, 690, 7, 39, 2, 2, 689, 691, 7, 59, 2, 2, 690, 689, 3, 2, 2,
	2, 690, 691, 3, 2, 2, 2, 691, 692, 3, 2, 2, 2, 692, 693, 5, 58, 30, 2,
	693, 694, 5, 76, 39, 2, 694, 695, 7, 5, 2, 2, 695, 722, 3, 2, 2, 2, 696,
	697, 7, 3, 2, 2, 697, 699, 7, 40, 2, 2, 698, 700, 7, 59, 2, 2, 699, 698,
	3, 2, 2, 2, 699, 700, 3, 2, 2, 2, 700, 701, 3, 2, 2, 2, 701, 705, 5, 58,
	30, 2, 702, 704, 5, 80, 41, 2, 703, 702, 3, 2, 2, 2, 704, 707, 3, 2, 2,
	2, 705, 703, 3, 2, 2, 2, 705, 706, 3, 2, 2, 2, 706, 708, 3, 2, 2, 2, 707,
	705, 3, 2, 2, 2, 708, 709, 7, 3, 2, 2, 709, 710, 7, 41, 2, 2, 710, 711,
	5, 76, 39, 2, 711, 717, 7, 5, 2, 2, 712, 713, 7, 3, 2, 2, 713, 714, 7,
	42, 2, 2, 714, 715, 5, 76, 39, 2, 715, 716, 7, 5, 2, 2, 716, 718, 3, 2,
	2, 2, 717, 712, 3, 2, 2, 2, 717, 718, 3, 2, 2, 2, 718, 719, 3, 2, 2, 2,
	719, 720, 7, 5, 2, 2, 720, 722, 3, 2, 2, 2, 721, 668, 3, 2, 2, 2, 721,
	678, 3, 2, 2, 2, 721, 687, 3, 2, 2, 2, 721, 696, 3, 2, 2, 2, 722, 81, 3,
	2, 2, 2, 723, 725, 7, 38, 2, 2, 724, 726, 7, 59, 2, 2, 725, 724, 3, 2,
	2, 2, 725, 726, 3, 2, 2, 2, 726, 727, 3, 2, 2, 2, 727, 728, 5, 58, 30,
	2, 728, 729, 5, 76, 39, 2, 729, 731, 7, 43, 2, 2, 730, 732, 7, 59, 2, 2,
	731, 730, 3, 2, 2, 2, 731, 732, 3, 2, 2, 2, 732, 761, 3, 2, 2, 2, 733,
	735, 7, 39, 2, 2, 734, 736, 7, 59, 2, 2, 735, 734, 3, 2, 2, 2, 735, 736,
	3, 2, 2, 2, 736, 737, 3, 2, 2, 2, 737, 738, 5, 58, 30, 2, 738, 739, 5,
	76, 39, 2, 739, 741, 7, 43, 2, 2, 740, 742, 7, 59, 2, 2, 741, 740, 3, 2,
	2, 2, 741, 742, 3, 2, 2, 2, 742, 761, 3, 2, 2, 2, 743, 745, 7, 40, 2, 2,
	744, 746, 7, 59, 2, 2, 745, 744, 3, 2, 2, 2, 745, 746, 3, 2, 2, 2, 746,
	747, 3, 2, 2, 2, 747, 748, 5, 58, 30, 2, 748, 754, 5, 76, 39, 2, 749, 751,
	7, 42, 2, 2, 750, 752, 7, 59, 2, 2, 751, 750, 3, 2, 2, 2, 751, 752, 3,
	2, 2, 2, 752, 753, 3, 2, 2, 2, 753, 755, 5, 76, 39, 2, 754, 749, 3, 2,
	2, 2, 754, 755, 3, 2, 2, 2, 755, 756, 3, 2, 2, 2, 756, 758, 7, 43, 2, 2,
	757, 759, 7, 59, 2, 2, 758, 757, 3, 2, 2, 2, 758, 759, 3, 2, 2, 2, 759,
	761, 3, 2, 2, 2, 760, 723, 3, 2, 2, 2, 760, 733, 3, 2, 2, 2, 760, 743,
	3, 2, 2, 2, 761, 83, 3, 2, 2, 2, 762, 790, 7, 44, 2, 2, 763, 790, 7, 45,
	2, 2, 764, 765, 7, 46, 2, 2, 765, 790, 5, 94, 48, 2, 766, 767, 7, 47, 2,
	2, 767, 790, 5, 94, 48, 2, 768, 770, 7, 48, 2, 2, 769, 771, 5, 94, 48,
	2, 770, 769, 3, 2, 2, 2, 771, 772, 3, 2, 2, 2, 772, 770, 3, 2, 2, 2, 772,
	773, 3, 2, 2, 2, 773, 790, 3, 2, 2, 2, 774, 790, 7, 49, 2, 2, 775, 776,
	7, 50, 2, 2, 776, 790, 5, 94, 48, 2, 777, 778, 7, 51, 2, 2, 778, 790, 5,
	52, 27, 2, 779, 790, 7, 52, 2, 2, 780, 790, 7, 53, 2, 2, 781, 782, 7, 64,
	2, 2, 782, 790, 5, 94, 48, 2, 783, 784, 7, 65, 2, 2, 784, 790, 5, 88, 45,
	2, 785, 790, 7, 54, 2, 2, 786, 790, 7, 55, 2, 2, 787, 790, 7, 67, 2, 2,
	788, 790, 5, 86, 44, 2, 789, 762, 3, 2, 2, 2, 789, 763, 3, 2, 2, 2, 789,
	764, 3, 2, 2, 2, 789, 766, 3, 2, 2, 2, 789, 768, 3, 2, 2, 2, 789, 774,
	3, 2, 2, 2, 789, 775, 3, 2, 2, 2, 789, 777, 3, 2, 2, 2, 789, 779, 3, 2,
	2, 2, 789, 780, 3, 2, 2, 2, 789, 781, 3, 2, 2, 2, 789, 783, 3, 2, 2, 2,
	789, 785, 3, 2, 2, 2, 789, 786, 3, 2, 2, 2, 789, 787, 3, 2, 2, 2, 789,
	788, 3, 2, 2, 2, 790, 85, 3, 2, 2, 2, 791, 792, 7, 66, 2, 2, 792, 793,
	5, 92, 47, 2, 793, 87, 3, 2, 2, 2, 794, 795, 7, 33, 2, 2, 795, 796, 7,
	56, 2, 2, 796, 798, 5, 90, 46, 2, 797, 794, 3, 2, 2, 2, 797, 798, 3, 2,
	2, 2, 798, 802, 3, 2, 2, 2, 799, 800, 7, 57, 2, 2, 800, 801, 7, 56, 2,
	2, 801, 803, 5, 90, 46, 2, 802, 799, 3, 2, 2, 2, 802, 803, 3, 2, 2, 2,
	803, 89, 3, 2, 2, 2, 804, 805, 7, 62, 2, 2, 805, 91, 3, 2, 2, 2, 806, 807,
	9, 2, 2, 2, 807, 93, 3, 2, 2, 2, 808, 809, 9, 3, 2, 2, 809, 95, 3, 2, 2,
	2, 91, 99, 109, 115, 121, 127, 134, 140, 144, 149, 158, 162, 170, 211,
	225, 230, 238, 245, 248, 251, 259, 264, 279, 284, 302, 310, 318, 326, 331,
	336, 343, 352, 359, 366, 376, 381, 390, 400, 410, 415, 424, 434, 442, 448,
	453, 463, 470, 498, 508, 520, 526, 531, 540, 548, 554, 559, 573, 581, 588,
	594, 597, 605, 616, 621, 627, 635, 645, 652, 660, 666, 673, 681, 690, 699,
	705, 717, 721, 725, 731, 735, 741, 745, 751, 754, 758, 760, 772, 789, 797,
	802,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'('", "'register'", "')'", "'module'", "'binary'", "'quote'", "'invoke'",
	"'get'", "'assert_return'", "'assert_trap'", "'assert_exhaustion'", "'assert_malformed'",
	"'assert_invalid'", "'assert_unlinkable'", "'nan:canonical'", "'nan:arithmetic'",
	"'script'", "'input'", "'output'", "'type'", "'func'", "'import'", "'table'",
	"'memory'", "'global'", "'local'", "'elem'", "'data'", "'export'", "'start'",
	"'offset'", "'mut'", "'funcref'", "'param'", "'result'", "'block'", "'loop'",
	"'if'", "'then'", "'else'", "'end'", "'unreachable'", "'nop'", "'br'",
	"'br_if'", "'br_table'", "'return'", "'call'", "'call_indirect'", "'drop'",
	"'select'", "'memory.size'", "'memory.grow'", "'='", "'align'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "VAL_TYPE", "NAME", "STRING", "FLOAT", "NAT", "INT", "VAR_OPS",
	"MEM_OPS", "CST_OPS", "NUM_OPS", "WS", "LINE_COMMENT", "BLOCK_COMMENT",
}

var ruleNames = []string{
	"script", "cmd", "wastModule", "action_", "assertion", "expected", "meta",
	"module", "watModule", "moduleField", "typeDef", "import_", "importDesc",
	"func_", "funcLocal", "table", "memory", "global", "export", "exportDesc",
	"start", "elem", "data", "embeddedIm", "embeddedEx", "typeUse", "funcVars",
	"valType", "blockType", "globalType", "memoryType", "tableType", "elemType",
	"limits", "funcType", "param", "result", "expr", "instr", "foldedInstr",
	"blockInstr", "plainInstr", "constInstr", "memArg", "nat", "value", "variable",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type WASTParser struct {
	*antlr.BaseParser
}

func NewWASTParser(input antlr.TokenStream) *WASTParser {
	this := new(WASTParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "WAST.g4"

	return this
}

// WASTParser tokens.
const (
	WASTParserEOF           = antlr.TokenEOF
	WASTParserT__0          = 1
	WASTParserT__1          = 2
	WASTParserT__2          = 3
	WASTParserT__3          = 4
	WASTParserT__4          = 5
	WASTParserT__5          = 6
	WASTParserT__6          = 7
	WASTParserT__7          = 8
	WASTParserT__8          = 9
	WASTParserT__9          = 10
	WASTParserT__10         = 11
	WASTParserT__11         = 12
	WASTParserT__12         = 13
	WASTParserT__13         = 14
	WASTParserT__14         = 15
	WASTParserT__15         = 16
	WASTParserT__16         = 17
	WASTParserT__17         = 18
	WASTParserT__18         = 19
	WASTParserT__19         = 20
	WASTParserT__20         = 21
	WASTParserT__21         = 22
	WASTParserT__22         = 23
	WASTParserT__23         = 24
	WASTParserT__24         = 25
	WASTParserT__25         = 26
	WASTParserT__26         = 27
	WASTParserT__27         = 28
	WASTParserT__28         = 29
	WASTParserT__29         = 30
	WASTParserT__30         = 31
	WASTParserT__31         = 32
	WASTParserT__32         = 33
	WASTParserT__33         = 34
	WASTParserT__34         = 35
	WASTParserT__35         = 36
	WASTParserT__36         = 37
	WASTParserT__37         = 38
	WASTParserT__38         = 39
	WASTParserT__39         = 40
	WASTParserT__40         = 41
	WASTParserT__41         = 42
	WASTParserT__42         = 43
	WASTParserT__43         = 44
	WASTParserT__44         = 45
	WASTParserT__45         = 46
	WASTParserT__46         = 47
	WASTParserT__47         = 48
	WASTParserT__48         = 49
	WASTParserT__49         = 50
	WASTParserT__50         = 51
	WASTParserT__51         = 52
	WASTParserT__52         = 53
	WASTParserT__53         = 54
	WASTParserT__54         = 55
	WASTParserVAL_TYPE      = 56
	WASTParserNAME          = 57
	WASTParserSTRING        = 58
	WASTParserFLOAT         = 59
	WASTParserNAT           = 60
	WASTParserINT           = 61
	WASTParserVAR_OPS       = 62
	WASTParserMEM_OPS       = 63
	WASTParserCST_OPS       = 64
	WASTParserNUM_OPS       = 65
	WASTParserWS            = 66
	WASTParserLINE_COMMENT  = 67
	WASTParserBLOCK_COMMENT = 68
)

// WASTParser rules.
const (
	WASTParserRULE_script      = 0
	WASTParserRULE_cmd         = 1
	WASTParserRULE_wastModule  = 2
	WASTParserRULE_action_     = 3
	WASTParserRULE_assertion   = 4
	WASTParserRULE_expected    = 5
	WASTParserRULE_meta        = 6
	WASTParserRULE_module      = 7
	WASTParserRULE_watModule   = 8
	WASTParserRULE_moduleField = 9
	WASTParserRULE_typeDef     = 10
	WASTParserRULE_import_     = 11
	WASTParserRULE_importDesc  = 12
	WASTParserRULE_func_       = 13
	WASTParserRULE_funcLocal   = 14
	WASTParserRULE_table       = 15
	WASTParserRULE_memory      = 16
	WASTParserRULE_global      = 17
	WASTParserRULE_export      = 18
	WASTParserRULE_exportDesc  = 19
	WASTParserRULE_start       = 20
	WASTParserRULE_elem        = 21
	WASTParserRULE_data        = 22
	WASTParserRULE_embeddedIm  = 23
	WASTParserRULE_embeddedEx  = 24
	WASTParserRULE_typeUse     = 25
	WASTParserRULE_funcVars    = 26
	WASTParserRULE_valType     = 27
	WASTParserRULE_blockType   = 28
	WASTParserRULE_globalType  = 29
	WASTParserRULE_memoryType  = 30
	WASTParserRULE_tableType   = 31
	WASTParserRULE_elemType    = 32
	WASTParserRULE_limits      = 33
	WASTParserRULE_funcType    = 34
	WASTParserRULE_param       = 35
	WASTParserRULE_result      = 36
	WASTParserRULE_expr        = 37
	WASTParserRULE_instr       = 38
	WASTParserRULE_foldedInstr = 39
	WASTParserRULE_blockInstr  = 40
	WASTParserRULE_plainInstr  = 41
	WASTParserRULE_constInstr  = 42
	WASTParserRULE_memArg      = 43
	WASTParserRULE_nat         = 44
	WASTParserRULE_value       = 45
	WASTParserRULE_variable    = 46
)

// IScriptContext is an interface to support dynamic dispatch.
type IScriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScriptContext differentiates from other interfaces.
	IsScriptContext()
}

type ScriptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScriptContext() *ScriptContext {
	var p = new(ScriptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_script
	return p
}

func (*ScriptContext) IsScriptContext() {}

func NewScriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptContext {
	var p = new(ScriptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_script

	return p
}

func (s *ScriptContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptContext) EOF() antlr.TerminalNode {
	return s.GetToken(WASTParserEOF, 0)
}

func (s *ScriptContext) AllCmd() []ICmdContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICmdContext)(nil)).Elem())
	var tst = make([]ICmdContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICmdContext)
		}
	}

	return tst
}

func (s *ScriptContext) Cmd(i int) ICmdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmdContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICmdContext)
}

func (s *ScriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitScript(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Script() (localctx IScriptContext) {
	localctx = NewScriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, WASTParserRULE_script)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(97)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == WASTParserT__0 {
		{
			p.SetState(94)
			p.Cmd()
		}

		p.SetState(99)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(100)
		p.Match(WASTParserEOF)
	}

	return localctx
}

// ICmdContext is an interface to support dynamic dispatch.
type ICmdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmdContext differentiates from other interfaces.
	IsCmdContext()
}

type CmdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmdContext() *CmdContext {
	var p = new(CmdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_cmd
	return p
}

func (*CmdContext) IsCmdContext() {}

func NewCmdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CmdContext {
	var p = new(CmdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_cmd

	return p
}

func (s *CmdContext) GetParser() antlr.Parser { return s.parser }

func (s *CmdContext) WastModule() IWastModuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWastModuleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWastModuleContext)
}

func (s *CmdContext) STRING() antlr.TerminalNode {
	return s.GetToken(WASTParserSTRING, 0)
}

func (s *CmdContext) NAME() antlr.TerminalNode {
	return s.GetToken(WASTParserNAME, 0)
}

func (s *CmdContext) Action_() IAction_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAction_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAction_Context)
}

func (s *CmdContext) Assertion() IAssertionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssertionContext)
}

func (s *CmdContext) Meta() IMetaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMetaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMetaContext)
}

func (s *CmdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CmdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CmdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitCmd(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Cmd() (localctx ICmdContext) {
	localctx = NewCmdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, WASTParserRULE_cmd)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(113)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(102)
			p.WastModule()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(103)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(104)
			p.Match(WASTParserT__1)
		}
		{
			p.SetState(105)
			p.Match(WASTParserSTRING)
		}
		p.SetState(107)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(106)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(109)
			p.Match(WASTParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(110)
			p.Action_()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(111)
			p.Assertion()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(112)
			p.Meta()
		}

	}

	return localctx
}

// IWastModuleContext is an interface to support dynamic dispatch.
type IWastModuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKind returns the kind token.
	GetKind() antlr.Token

	// SetKind sets the kind token.
	SetKind(antlr.Token)

	// IsWastModuleContext differentiates from other interfaces.
	IsWastModuleContext()
}

type WastModuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	kind   antlr.Token
}

func NewEmptyWastModuleContext() *WastModuleContext {
	var p = new(WastModuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_wastModule
	return p
}

func (*WastModuleContext) IsWastModuleContext() {}

func NewWastModuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WastModuleContext {
	var p = new(WastModuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_wastModule

	return p
}

func (s *WastModuleContext) GetParser() antlr.Parser { return s.parser }

func (s *WastModuleContext) GetKind() antlr.Token { return s.kind }

func (s *WastModuleContext) SetKind(v antlr.Token) { s.kind = v }

func (s *WastModuleContext) WatModule() IWatModuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWatModuleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWatModuleContext)
}

func (s *WastModuleContext) NAME() antlr.TerminalNode {
	return s.GetToken(WASTParserNAME, 0)
}

func (s *WastModuleContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(WASTParserSTRING)
}

func (s *WastModuleContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(WASTParserSTRING, i)
}

func (s *WastModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WastModuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WastModuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitWastModule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) WastModule() (localctx IWastModuleContext) {
	localctx = NewWastModuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, WASTParserRULE_wastModule)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(142)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(115)
			p.WatModule()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(116)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(117)
			p.Match(WASTParserT__3)
		}
		p.SetState(119)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(118)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(121)

			var _m = p.Match(WASTParserT__4)

			localctx.(*WastModuleContext).kind = _m
		}
		p.SetState(125)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == WASTParserSTRING {
			{
				p.SetState(122)
				p.Match(WASTParserSTRING)
			}

			p.SetState(127)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(128)
			p.Match(WASTParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(129)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(130)
			p.Match(WASTParserT__3)
		}
		p.SetState(132)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(131)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(134)

			var _m = p.Match(WASTParserT__5)

			localctx.(*WastModuleContext).kind = _m
		}
		p.SetState(138)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == WASTParserSTRING {
			{
				p.SetState(135)
				p.Match(WASTParserSTRING)
			}

			p.SetState(140)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(141)
			p.Match(WASTParserT__2)
		}

	}

	return localctx
}

// IAction_Context is an interface to support dynamic dispatch.
type IAction_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKind returns the kind token.
	GetKind() antlr.Token

	// SetKind sets the kind token.
	SetKind(antlr.Token)

	// IsAction_Context differentiates from other interfaces.
	IsAction_Context()
}

type Action_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	kind   antlr.Token
}

func NewEmptyAction_Context() *Action_Context {
	var p = new(Action_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_action_
	return p
}

func (*Action_Context) IsAction_Context() {}

func NewAction_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Action_Context {
	var p = new(Action_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_action_

	return p
}

func (s *Action_Context) GetParser() antlr.Parser { return s.parser }

func (s *Action_Context) GetKind() antlr.Token { return s.kind }

func (s *Action_Context) SetKind(v antlr.Token) { s.kind = v }

func (s *Action_Context) STRING() antlr.TerminalNode {
	return s.GetToken(WASTParserSTRING, 0)
}

func (s *Action_Context) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Action_Context) NAME() antlr.TerminalNode {
	return s.GetToken(WASTParserNAME, 0)
}

func (s *Action_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Action_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Action_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitAction_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Action_() (localctx IAction_Context) {
	localctx = NewAction_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, WASTParserRULE_action_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(160)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(144)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(145)

			var _m = p.Match(WASTParserT__6)

			localctx.(*Action_Context).kind = _m
		}
		p.SetState(147)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(146)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(149)
			p.Match(WASTParserSTRING)
		}
		{
			p.SetState(150)
			p.Expr()
		}
		{
			p.SetState(151)
			p.Match(WASTParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(153)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(154)

			var _m = p.Match(WASTParserT__7)

			localctx.(*Action_Context).kind = _m
		}
		p.SetState(156)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(155)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(158)
			p.Match(WASTParserSTRING)
		}
		{
			p.SetState(159)
			p.Match(WASTParserT__2)
		}

	}

	return localctx
}

// IAssertionContext is an interface to support dynamic dispatch.
type IAssertionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKind returns the kind token.
	GetKind() antlr.Token

	// SetKind sets the kind token.
	SetKind(antlr.Token)

	// IsAssertionContext differentiates from other interfaces.
	IsAssertionContext()
}

type AssertionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	kind   antlr.Token
}

func NewEmptyAssertionContext() *AssertionContext {
	var p = new(AssertionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_assertion
	return p
}

func (*AssertionContext) IsAssertionContext() {}

func NewAssertionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssertionContext {
	var p = new(AssertionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_assertion

	return p
}

func (s *AssertionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssertionContext) GetKind() antlr.Token { return s.kind }

func (s *AssertionContext) SetKind(v antlr.Token) { s.kind = v }

func (s *AssertionContext) Action_() IAction_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAction_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAction_Context)
}

func (s *AssertionContext) AllExpected() []IExpectedContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpectedContext)(nil)).Elem())
	var tst = make([]IExpectedContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpectedContext)
		}
	}

	return tst
}

func (s *AssertionContext) Expected(i int) IExpectedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpectedContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpectedContext)
}

func (s *AssertionContext) STRING() antlr.TerminalNode {
	return s.GetToken(WASTParserSTRING, 0)
}

func (s *AssertionContext) WastModule() IWastModuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWastModuleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWastModuleContext)
}

func (s *AssertionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssertionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitAssertion(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Assertion() (localctx IAssertionContext) {
	localctx = NewAssertionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, WASTParserRULE_assertion)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(209)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(162)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(163)

			var _m = p.Match(WASTParserT__8)

			localctx.(*AssertionContext).kind = _m
		}
		{
			p.SetState(164)
			p.Action_()
		}
		p.SetState(168)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == WASTParserT__0 {
			{
				p.SetState(165)
				p.Expected()
			}

			p.SetState(170)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(171)
			p.Match(WASTParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(173)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(174)

			var _m = p.Match(WASTParserT__9)

			localctx.(*AssertionContext).kind = _m
		}
		{
			p.SetState(175)
			p.Action_()
		}
		{
			p.SetState(176)
			p.Match(WASTParserSTRING)
		}
		{
			p.SetState(177)
			p.Match(WASTParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(179)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(180)

			var _m = p.Match(WASTParserT__10)

			localctx.(*AssertionContext).kind = _m
		}
		{
			p.SetState(181)
			p.Action_()
		}
		{
			p.SetState(182)
			p.Match(WASTParserSTRING)
		}
		{
			p.SetState(183)
			p.Match(WASTParserT__2)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(185)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(186)

			var _m = p.Match(WASTParserT__11)

			localctx.(*AssertionContext).kind = _m
		}
		{
			p.SetState(187)
			p.WastModule()
		}
		{
			p.SetState(188)
			p.Match(WASTParserSTRING)
		}
		{
			p.SetState(189)
			p.Match(WASTParserT__2)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(191)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(192)

			var _m = p.Match(WASTParserT__12)

			localctx.(*AssertionContext).kind = _m
		}
		{
			p.SetState(193)
			p.WastModule()
		}
		{
			p.SetState(194)
			p.Match(WASTParserSTRING)
		}
		{
			p.SetState(195)
			p.Match(WASTParserT__2)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(197)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(198)

			var _m = p.Match(WASTParserT__13)

			localctx.(*AssertionContext).kind = _m
		}
		{
			p.SetState(199)
			p.WastModule()
		}
		{
			p.SetState(200)
			p.Match(WASTParserSTRING)
		}
		{
			p.SetState(201)
			p.Match(WASTParserT__2)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(203)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(204)

			var _m = p.Match(WASTParserT__9)

			localctx.(*AssertionContext).kind = _m
		}
		{
			p.SetState(205)
			p.WastModule()
		}
		{
			p.SetState(206)
			p.Match(WASTParserSTRING)
		}
		{
			p.SetState(207)
			p.Match(WASTParserT__2)
		}

	}

	return localctx
}

// IExpectedContext is an interface to support dynamic dispatch.
type IExpectedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// GetNan returns the nan token.
	GetNan() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// SetNan sets the nan token.
	SetNan(antlr.Token)

	// IsExpectedContext differentiates from other interfaces.
	IsExpectedContext()
}

type ExpectedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
	nan    antlr.Token
}

func NewEmptyExpectedContext() *ExpectedContext {
	var p = new(ExpectedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_expected
	return p
}

func (*ExpectedContext) IsExpectedContext() {}

func NewExpectedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpectedContext {
	var p = new(ExpectedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_expected

	return p
}

func (s *ExpectedContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpectedContext) GetOp() antlr.Token { return s.op }

func (s *ExpectedContext) GetNan() antlr.Token { return s.nan }

func (s *ExpectedContext) SetOp(v antlr.Token) { s.op = v }

func (s *ExpectedContext) SetNan(v antlr.Token) { s.nan = v }

func (s *ExpectedContext) ConstInstr() IConstInstrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstInstrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstInstrContext)
}

func (s *ExpectedContext) CST_OPS() antlr.TerminalNode {
	return s.GetToken(WASTParserCST_OPS, 0)
}

func (s *ExpectedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpectedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpectedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitExpected(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Expected() (localctx IExpectedContext) {
	localctx = NewExpectedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, WASTParserRULE_expected)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(223)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(211)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(212)
			p.ConstInstr()
		}
		{
			p.SetState(213)
			p.Match(WASTParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(215)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(216)

			var _m = p.Match(WASTParserCST_OPS)

			localctx.(*ExpectedContext).op = _m
		}
		{
			p.SetState(217)

			var _m = p.Match(WASTParserT__14)

			localctx.(*ExpectedContext).nan = _m
		}
		{
			p.SetState(218)
			p.Match(WASTParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(219)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(220)

			var _m = p.Match(WASTParserCST_OPS)

			localctx.(*ExpectedContext).op = _m
		}
		{
			p.SetState(221)

			var _m = p.Match(WASTParserT__15)

			localctx.(*ExpectedContext).nan = _m
		}
		{
			p.SetState(222)
			p.Match(WASTParserT__2)
		}

	}

	return localctx
}

// IMetaContext is an interface to support dynamic dispatch.
type IMetaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMetaContext differentiates from other interfaces.
	IsMetaContext()
}

type MetaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMetaContext() *MetaContext {
	var p = new(MetaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_meta
	return p
}

func (*MetaContext) IsMetaContext() {}

func NewMetaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MetaContext {
	var p = new(MetaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_meta

	return p
}

func (s *MetaContext) GetParser() antlr.Parser { return s.parser }

func (s *MetaContext) Script() IScriptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScriptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScriptContext)
}

func (s *MetaContext) NAME() antlr.TerminalNode {
	return s.GetToken(WASTParserNAME, 0)
}

func (s *MetaContext) STRING() antlr.TerminalNode {
	return s.GetToken(WASTParserSTRING, 0)
}

func (s *MetaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MetaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitMeta(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Meta() (localctx IMetaContext) {
	localctx = NewMetaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, WASTParserRULE_meta)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(249)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(225)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(226)
			p.Match(WASTParserT__16)
		}
		p.SetState(228)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(227)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(230)
			p.Script()
		}
		{
			p.SetState(231)
			p.Match(WASTParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(233)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(234)
			p.Match(WASTParserT__17)
		}
		p.SetState(236)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(235)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(238)
			p.Match(WASTParserSTRING)
		}
		{
			p.SetState(239)
			p.Match(WASTParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(240)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(241)
			p.Match(WASTParserT__18)
		}
		p.SetState(243)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(242)
				p.Match(WASTParserNAME)
			}

		}
		p.SetState(246)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserSTRING {
			{
				p.SetState(245)
				p.Match(WASTParserSTRING)
			}

		}
		{
			p.SetState(248)
			p.Match(WASTParserT__2)
		}

	}

	return localctx
}

// IModuleContext is an interface to support dynamic dispatch.
type IModuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleContext differentiates from other interfaces.
	IsModuleContext()
}

type ModuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleContext() *ModuleContext {
	var p = new(ModuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_module
	return p
}

func (*ModuleContext) IsModuleContext() {}

func NewModuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleContext {
	var p = new(ModuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_module

	return p
}

func (s *ModuleContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleContext) WatModule() IWatModuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWatModuleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWatModuleContext)
}

func (s *ModuleContext) EOF() antlr.TerminalNode {
	return s.GetToken(WASTParserEOF, 0)
}

func (s *ModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitModule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Module() (localctx IModuleContext) {
	localctx = NewModuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, WASTParserRULE_module)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(251)
		p.WatModule()
	}
	{
		p.SetState(252)
		p.Match(WASTParserEOF)
	}

	return localctx
}

// IWatModuleContext is an interface to support dynamic dispatch.
type IWatModuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKw returns the kw token.
	GetKw() antlr.Token

	// SetKw sets the kw token.
	SetKw(antlr.Token)

	// IsWatModuleContext differentiates from other interfaces.
	IsWatModuleContext()
}

type WatModuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	kw     antlr.Token
}

func NewEmptyWatModuleContext() *WatModuleContext {
	var p = new(WatModuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_watModule
	return p
}

func (*WatModuleContext) IsWatModuleContext() {}

func NewWatModuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WatModuleContext {
	var p = new(WatModuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_watModule

	return p
}

func (s *WatModuleContext) GetParser() antlr.Parser { return s.parser }

func (s *WatModuleContext) GetKw() antlr.Token { return s.kw }

func (s *WatModuleContext) SetKw(v antlr.Token) { s.kw = v }

func (s *WatModuleContext) NAME() antlr.TerminalNode {
	return s.GetToken(WASTParserNAME, 0)
}

func (s *WatModuleContext) AllModuleField() []IModuleFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModuleFieldContext)(nil)).Elem())
	var tst = make([]IModuleFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModuleFieldContext)
		}
	}

	return tst
}

func (s *WatModuleContext) ModuleField(i int) IModuleFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModuleFieldContext)
}

func (s *WatModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WatModuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WatModuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitWatModule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) WatModule() (localctx IWatModuleContext) {
	localctx = NewWatModuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, WASTParserRULE_watModule)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(254)
		p.Match(WASTParserT__0)
	}
	{
		p.SetState(255)

		var _m = p.Match(WASTParserT__3)

		localctx.(*WatModuleContext).kw = _m
	}
	p.SetState(257)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == WASTParserNAME {
		{
			p.SetState(256)
			p.Match(WASTParserNAME)
		}

	}
	p.SetState(262)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == WASTParserT__0 {
		{
			p.SetState(259)
			p.ModuleField()
		}

		p.SetState(264)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(265)
		p.Match(WASTParserT__2)
	}

	return localctx
}

// IModuleFieldContext is an interface to support dynamic dispatch.
type IModuleFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleFieldContext differentiates from other interfaces.
	IsModuleFieldContext()
}

type ModuleFieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleFieldContext() *ModuleFieldContext {
	var p = new(ModuleFieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_moduleField
	return p
}

func (*ModuleFieldContext) IsModuleFieldContext() {}

func NewModuleFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleFieldContext {
	var p = new(ModuleFieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_moduleField

	return p
}

func (s *ModuleFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleFieldContext) TypeDef() ITypeDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeDefContext)
}

func (s *ModuleFieldContext) Import_() IImport_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_Context)
}

func (s *ModuleFieldContext) Func_() IFunc_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunc_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunc_Context)
}

func (s *ModuleFieldContext) Table() ITableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *ModuleFieldContext) Memory() IMemoryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemoryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMemoryContext)
}

func (s *ModuleFieldContext) Global() IGlobalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobalContext)
}

func (s *ModuleFieldContext) Export() IExportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExportContext)
}

func (s *ModuleFieldContext) Start() IStartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStartContext)
}

func (s *ModuleFieldContext) Elem() IElemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElemContext)
}

func (s *ModuleFieldContext) Data() IDataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataContext)
}

func (s *ModuleFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitModuleField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) ModuleField() (localctx IModuleFieldContext) {
	localctx = NewModuleFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, WASTParserRULE_moduleField)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(277)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(267)
			p.TypeDef()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(268)
			p.Import_()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(269)
			p.Func_()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(270)
			p.Table()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(271)
			p.Memory()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(272)
			p.Global()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(273)
			p.Export()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(274)
			p.Start()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(275)
			p.Elem()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(276)
			p.Data()
		}

	}

	return localctx
}

// ITypeDefContext is an interface to support dynamic dispatch.
type ITypeDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeDefContext differentiates from other interfaces.
	IsTypeDefContext()
}

type TypeDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDefContext() *TypeDefContext {
	var p = new(TypeDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_typeDef
	return p
}

func (*TypeDefContext) IsTypeDefContext() {}

func NewTypeDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefContext {
	var p = new(TypeDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_typeDef

	return p
}

func (s *TypeDefContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefContext) FuncType() IFuncTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncTypeContext)
}

func (s *TypeDefContext) NAME() antlr.TerminalNode {
	return s.GetToken(WASTParserNAME, 0)
}

func (s *TypeDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitTypeDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) TypeDef() (localctx ITypeDefContext) {
	localctx = NewTypeDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, WASTParserRULE_typeDef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(279)
		p.Match(WASTParserT__0)
	}
	{
		p.SetState(280)
		p.Match(WASTParserT__19)
	}
	p.SetState(282)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == WASTParserNAME {
		{
			p.SetState(281)
			p.Match(WASTParserNAME)
		}

	}
	{
		p.SetState(284)
		p.Match(WASTParserT__0)
	}
	{
		p.SetState(285)
		p.Match(WASTParserT__20)
	}
	{
		p.SetState(286)
		p.FuncType()
	}
	{
		p.SetState(287)
		p.Match(WASTParserT__2)
	}
	{
		p.SetState(288)
		p.Match(WASTParserT__2)
	}

	return localctx
}

// IImport_Context is an interface to support dynamic dispatch.
type IImport_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_Context differentiates from other interfaces.
	IsImport_Context()
}

type Import_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_Context() *Import_Context {
	var p = new(Import_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_import_
	return p
}

func (*Import_Context) IsImport_Context() {}

func NewImport_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_Context {
	var p = new(Import_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_import_

	return p
}

func (s *Import_Context) GetParser() antlr.Parser { return s.parser }

func (s *Import_Context) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(WASTParserSTRING)
}

func (s *Import_Context) STRING(i int) antlr.TerminalNode {
	return s.GetToken(WASTParserSTRING, i)
}

func (s *Import_Context) ImportDesc() IImportDescContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportDescContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImportDescContext)
}

func (s *Import_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitImport_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Import_() (localctx IImport_Context) {
	localctx = NewImport_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, WASTParserRULE_import_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(290)
		p.Match(WASTParserT__0)
	}
	{
		p.SetState(291)
		p.Match(WASTParserT__21)
	}
	{
		p.SetState(292)
		p.Match(WASTParserSTRING)
	}
	{
		p.SetState(293)
		p.Match(WASTParserSTRING)
	}
	{
		p.SetState(294)
		p.ImportDesc()
	}
	{
		p.SetState(295)
		p.Match(WASTParserT__2)
	}

	return localctx
}

// IImportDescContext is an interface to support dynamic dispatch.
type IImportDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKind returns the kind token.
	GetKind() antlr.Token

	// SetKind sets the kind token.
	SetKind(antlr.Token)

	// IsImportDescContext differentiates from other interfaces.
	IsImportDescContext()
}

type ImportDescContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	kind   antlr.Token
}

func NewEmptyImportDescContext() *ImportDescContext {
	var p = new(ImportDescContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_importDesc
	return p
}

func (*ImportDescContext) IsImportDescContext() {}

func NewImportDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDescContext {
	var p = new(ImportDescContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_importDesc

	return p
}

func (s *ImportDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDescContext) GetKind() antlr.Token { return s.kind }

func (s *ImportDescContext) SetKind(v antlr.Token) { s.kind = v }

func (s *ImportDescContext) TypeUse() ITypeUseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeUseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeUseContext)
}

func (s *ImportDescContext) NAME() antlr.TerminalNode {
	return s.GetToken(WASTParserNAME, 0)
}

func (s *ImportDescContext) TableType() ITableTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableTypeContext)
}

func (s *ImportDescContext) MemoryType() IMemoryTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemoryTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMemoryTypeContext)
}

func (s *ImportDescContext) GlobalType() IGlobalTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobalTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobalTypeContext)
}

func (s *ImportDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitImportDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) ImportDesc() (localctx IImportDescContext) {
	localctx = NewImportDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, WASTParserRULE_importDesc)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(329)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(297)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(298)

			var _m = p.Match(WASTParserT__20)

			localctx.(*ImportDescContext).kind = _m
		}
		p.SetState(300)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(299)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(302)
			p.TypeUse()
		}
		{
			p.SetState(303)
			p.Match(WASTParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(305)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(306)

			var _m = p.Match(WASTParserT__22)

			localctx.(*ImportDescContext).kind = _m
		}
		p.SetState(308)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(307)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(310)
			p.TableType()
		}
		{
			p.SetState(311)
			p.Match(WASTParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(313)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(314)

			var _m = p.Match(WASTParserT__23)

			localctx.(*ImportDescContext).kind = _m
		}
		p.SetState(316)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(315)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(318)
			p.MemoryType()
		}
		{
			p.SetState(319)
			p.Match(WASTParserT__2)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(321)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(322)

			var _m = p.Match(WASTParserT__24)

			localctx.(*ImportDescContext).kind = _m
		}
		p.SetState(324)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(323)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(326)
			p.GlobalType()
		}
		{
			p.SetState(327)
			p.Match(WASTParserT__2)
		}

	}

	return localctx
}

// IFunc_Context is an interface to support dynamic dispatch.
type IFunc_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunc_Context differentiates from other interfaces.
	IsFunc_Context()
}

type Func_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_Context() *Func_Context {
	var p = new(Func_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_func_
	return p
}

func (*Func_Context) IsFunc_Context() {}

func NewFunc_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_Context {
	var p = new(Func_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_func_

	return p
}

func (s *Func_Context) GetParser() antlr.Parser { return s.parser }

func (s *Func_Context) EmbeddedEx() IEmbeddedExContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmbeddedExContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmbeddedExContext)
}

func (s *Func_Context) TypeUse() ITypeUseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeUseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeUseContext)
}

func (s *Func_Context) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Func_Context) NAME() antlr.TerminalNode {
	return s.GetToken(WASTParserNAME, 0)
}

func (s *Func_Context) AllFuncLocal() []IFuncLocalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFuncLocalContext)(nil)).Elem())
	var tst = make([]IFuncLocalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFuncLocalContext)
		}
	}

	return tst
}

func (s *Func_Context) FuncLocal(i int) IFuncLocalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncLocalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFuncLocalContext)
}

func (s *Func_Context) EmbeddedIm() IEmbeddedImContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmbeddedImContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmbeddedImContext)
}

func (s *Func_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitFunc_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Func_() (localctx IFunc_Context) {
	localctx = NewFunc_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, WASTParserRULE_func_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(357)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(331)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(332)
			p.Match(WASTParserT__20)
		}
		p.SetState(334)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(333)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(336)
			p.EmbeddedEx()
		}
		{
			p.SetState(337)
			p.TypeUse()
		}
		p.SetState(341)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(338)
					p.FuncLocal()
				}

			}
			p.SetState(343)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext())
		}
		{
			p.SetState(344)
			p.Expr()
		}
		{
			p.SetState(345)
			p.Match(WASTParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(347)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(348)
			p.Match(WASTParserT__20)
		}
		p.SetState(350)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(349)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(352)
			p.EmbeddedEx()
		}
		{
			p.SetState(353)
			p.EmbeddedIm()
		}
		{
			p.SetState(354)
			p.TypeUse()
		}
		{
			p.SetState(355)
			p.Match(WASTParserT__2)
		}

	}

	return localctx
}

// IFuncLocalContext is an interface to support dynamic dispatch.
type IFuncLocalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFuncLocalContext differentiates from other interfaces.
	IsFuncLocalContext()
}

type FuncLocalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncLocalContext() *FuncLocalContext {
	var p = new(FuncLocalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_funcLocal
	return p
}

func (*FuncLocalContext) IsFuncLocalContext() {}

func NewFuncLocalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncLocalContext {
	var p = new(FuncLocalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_funcLocal

	return p
}

func (s *FuncLocalContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncLocalContext) AllValType() []IValTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValTypeContext)(nil)).Elem())
	var tst = make([]IValTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValTypeContext)
		}
	}

	return tst
}

func (s *FuncLocalContext) ValType(i int) IValTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValTypeContext)
}

func (s *FuncLocalContext) NAME() antlr.TerminalNode {
	return s.GetToken(WASTParserNAME, 0)
}

func (s *FuncLocalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncLocalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncLocalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitFuncLocal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) FuncLocal() (localctx IFuncLocalContext) {
	localctx = NewFuncLocalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, WASTParserRULE_funcLocal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(374)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(359)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(360)
			p.Match(WASTParserT__25)
		}
		p.SetState(364)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == WASTParserVAL_TYPE {
			{
				p.SetState(361)
				p.ValType()
			}

			p.SetState(366)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(367)
			p.Match(WASTParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(368)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(369)
			p.Match(WASTParserT__25)
		}
		{
			p.SetState(370)
			p.Match(WASTParserNAME)
		}
		{
			p.SetState(371)
			p.ValType()
		}
		{
			p.SetState(372)
			p.Match(WASTParserT__2)
		}

	}

	return localctx
}

// ITableContext is an interface to support dynamic dispatch.
type ITableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableContext differentiates from other interfaces.
	IsTableContext()
}

type TableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableContext() *TableContext {
	var p = new(TableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_table
	return p
}

func (*TableContext) IsTableContext() {}

func NewTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableContext {
	var p = new(TableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_table

	return p
}

func (s *TableContext) GetParser() antlr.Parser { return s.parser }

func (s *TableContext) EmbeddedEx() IEmbeddedExContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmbeddedExContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmbeddedExContext)
}

func (s *TableContext) TableType() ITableTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableTypeContext)
}

func (s *TableContext) NAME() antlr.TerminalNode {
	return s.GetToken(WASTParserNAME, 0)
}

func (s *TableContext) EmbeddedIm() IEmbeddedImContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmbeddedImContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmbeddedImContext)
}

func (s *TableContext) ElemType() IElemTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElemTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElemTypeContext)
}

func (s *TableContext) FuncVars() IFuncVarsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncVarsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncVarsContext)
}

func (s *TableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Table() (localctx ITableContext) {
	localctx = NewTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, WASTParserRULE_table)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(408)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(376)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(377)
			p.Match(WASTParserT__22)
		}
		p.SetState(379)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(378)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(381)
			p.EmbeddedEx()
		}
		{
			p.SetState(382)
			p.TableType()
		}
		{
			p.SetState(383)
			p.Match(WASTParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(385)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(386)
			p.Match(WASTParserT__22)
		}
		p.SetState(388)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(387)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(390)
			p.EmbeddedEx()
		}
		{
			p.SetState(391)
			p.EmbeddedIm()
		}
		{
			p.SetState(392)
			p.TableType()
		}
		{
			p.SetState(393)
			p.Match(WASTParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(395)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(396)
			p.Match(WASTParserT__22)
		}
		p.SetState(398)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(397)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(400)
			p.EmbeddedEx()
		}
		{
			p.SetState(401)
			p.ElemType()
		}
		{
			p.SetState(402)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(403)
			p.Match(WASTParserT__26)
		}
		{
			p.SetState(404)
			p.FuncVars()
		}
		{
			p.SetState(405)
			p.Match(WASTParserT__2)
		}
		{
			p.SetState(406)
			p.Match(WASTParserT__2)
		}

	}

	return localctx
}

// IMemoryContext is an interface to support dynamic dispatch.
type IMemoryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemoryContext differentiates from other interfaces.
	IsMemoryContext()
}

type MemoryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemoryContext() *MemoryContext {
	var p = new(MemoryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_memory
	return p
}

func (*MemoryContext) IsMemoryContext() {}

func NewMemoryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemoryContext {
	var p = new(MemoryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_memory

	return p
}

func (s *MemoryContext) GetParser() antlr.Parser { return s.parser }

func (s *MemoryContext) EmbeddedEx() IEmbeddedExContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmbeddedExContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmbeddedExContext)
}

func (s *MemoryContext) MemoryType() IMemoryTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemoryTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMemoryTypeContext)
}

func (s *MemoryContext) NAME() antlr.TerminalNode {
	return s.GetToken(WASTParserNAME, 0)
}

func (s *MemoryContext) EmbeddedIm() IEmbeddedImContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmbeddedImContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmbeddedImContext)
}

func (s *MemoryContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(WASTParserSTRING)
}

func (s *MemoryContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(WASTParserSTRING, i)
}

func (s *MemoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemoryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemoryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitMemory(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Memory() (localctx IMemoryContext) {
	localctx = NewMemoryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, WASTParserRULE_memory)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(446)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(410)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(411)
			p.Match(WASTParserT__23)
		}
		p.SetState(413)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(412)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(415)
			p.EmbeddedEx()
		}
		{
			p.SetState(416)
			p.MemoryType()
		}
		{
			p.SetState(417)
			p.Match(WASTParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(419)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(420)
			p.Match(WASTParserT__23)
		}
		p.SetState(422)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(421)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(424)
			p.EmbeddedEx()
		}
		{
			p.SetState(425)
			p.EmbeddedIm()
		}
		{
			p.SetState(426)
			p.MemoryType()
		}
		{
			p.SetState(427)
			p.Match(WASTParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(429)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(430)
			p.Match(WASTParserT__23)
		}
		p.SetState(432)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(431)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(434)
			p.EmbeddedEx()
		}
		{
			p.SetState(435)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(436)
			p.Match(WASTParserT__27)
		}
		p.SetState(440)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == WASTParserSTRING {
			{
				p.SetState(437)
				p.Match(WASTParserSTRING)
			}

			p.SetState(442)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(443)
			p.Match(WASTParserT__2)
		}
		{
			p.SetState(444)
			p.Match(WASTParserT__2)
		}

	}

	return localctx
}

// IGlobalContext is an interface to support dynamic dispatch.
type IGlobalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobalContext differentiates from other interfaces.
	IsGlobalContext()
}

type GlobalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalContext() *GlobalContext {
	var p = new(GlobalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_global
	return p
}

func (*GlobalContext) IsGlobalContext() {}

func NewGlobalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalContext {
	var p = new(GlobalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_global

	return p
}

func (s *GlobalContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalContext) EmbeddedEx() IEmbeddedExContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmbeddedExContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmbeddedExContext)
}

func (s *GlobalContext) GlobalType() IGlobalTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobalTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobalTypeContext)
}

func (s *GlobalContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *GlobalContext) NAME() antlr.TerminalNode {
	return s.GetToken(WASTParserNAME, 0)
}

func (s *GlobalContext) EmbeddedIm() IEmbeddedImContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmbeddedImContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmbeddedImContext)
}

func (s *GlobalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitGlobal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Global() (localctx IGlobalContext) {
	localctx = NewGlobalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, WASTParserRULE_global)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(468)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(448)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(449)
			p.Match(WASTParserT__24)
		}
		p.SetState(451)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(450)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(453)
			p.EmbeddedEx()
		}
		{
			p.SetState(454)
			p.GlobalType()
		}
		{
			p.SetState(455)
			p.Expr()
		}
		{
			p.SetState(456)
			p.Match(WASTParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(458)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(459)
			p.Match(WASTParserT__24)
		}
		p.SetState(461)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(460)
				p.Match(WASTParserNAME)
			}

		}
		{
			p.SetState(463)
			p.EmbeddedEx()
		}
		{
			p.SetState(464)
			p.EmbeddedIm()
		}
		{
			p.SetState(465)
			p.GlobalType()
		}
		{
			p.SetState(466)
			p.Match(WASTParserT__2)
		}

	}

	return localctx
}

// IExportContext is an interface to support dynamic dispatch.
type IExportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExportContext differentiates from other interfaces.
	IsExportContext()
}

type ExportContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportContext() *ExportContext {
	var p = new(ExportContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_export
	return p
}

func (*ExportContext) IsExportContext() {}

func NewExportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportContext {
	var p = new(ExportContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_export

	return p
}

func (s *ExportContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportContext) STRING() antlr.TerminalNode {
	return s.GetToken(WASTParserSTRING, 0)
}

func (s *ExportContext) ExportDesc() IExportDescContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExportDescContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExportDescContext)
}

func (s *ExportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitExport(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Export() (localctx IExportContext) {
	localctx = NewExportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, WASTParserRULE_export)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(470)
		p.Match(WASTParserT__0)
	}
	{
		p.SetState(471)
		p.Match(WASTParserT__28)
	}
	{
		p.SetState(472)
		p.Match(WASTParserSTRING)
	}
	{
		p.SetState(473)
		p.ExportDesc()
	}
	{
		p.SetState(474)
		p.Match(WASTParserT__2)
	}

	return localctx
}

// IExportDescContext is an interface to support dynamic dispatch.
type IExportDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKind returns the kind token.
	GetKind() antlr.Token

	// SetKind sets the kind token.
	SetKind(antlr.Token)

	// IsExportDescContext differentiates from other interfaces.
	IsExportDescContext()
}

type ExportDescContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	kind   antlr.Token
}

func NewEmptyExportDescContext() *ExportDescContext {
	var p = new(ExportDescContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_exportDesc
	return p
}

func (*ExportDescContext) IsExportDescContext() {}

func NewExportDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportDescContext {
	var p = new(ExportDescContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_exportDesc

	return p
}

func (s *ExportDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportDescContext) GetKind() antlr.Token { return s.kind }

func (s *ExportDescContext) SetKind(v antlr.Token) { s.kind = v }

func (s *ExportDescContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *ExportDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitExportDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) ExportDesc() (localctx IExportDescContext) {
	localctx = NewExportDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, WASTParserRULE_exportDesc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(496)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(476)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(477)

			var _m = p.Match(WASTParserT__20)

			localctx.(*ExportDescContext).kind = _m
		}
		{
			p.SetState(478)
			p.Variable()
		}
		{
			p.SetState(479)
			p.Match(WASTParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(481)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(482)

			var _m = p.Match(WASTParserT__22)

			localctx.(*ExportDescContext).kind = _m
		}
		{
			p.SetState(483)
			p.Variable()
		}
		{
			p.SetState(484)
			p.Match(WASTParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(486)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(487)

			var _m = p.Match(WASTParserT__23)

			localctx.(*ExportDescContext).kind = _m
		}
		{
			p.SetState(488)
			p.Variable()
		}
		{
			p.SetState(489)
			p.Match(WASTParserT__2)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(491)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(492)

			var _m = p.Match(WASTParserT__24)

			localctx.(*ExportDescContext).kind = _m
		}
		{
			p.SetState(493)
			p.Variable()
		}
		{
			p.SetState(494)
			p.Match(WASTParserT__2)
		}

	}

	return localctx
}

// IStartContext is an interface to support dynamic dispatch.
type IStartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStartContext differentiates from other interfaces.
	IsStartContext()
}

type StartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartContext() *StartContext {
	var p = new(StartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_start
	return p
}

func (*StartContext) IsStartContext() {}

func NewStartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartContext {
	var p = new(StartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_start

	return p
}

func (s *StartContext) GetParser() antlr.Parser { return s.parser }

func (s *StartContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *StartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitStart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Start() (localctx IStartContext) {
	localctx = NewStartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, WASTParserRULE_start)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(498)
		p.Match(WASTParserT__0)
	}
	{
		p.SetState(499)
		p.Match(WASTParserT__29)
	}
	{
		p.SetState(500)
		p.Variable()
	}
	{
		p.SetState(501)
		p.Match(WASTParserT__2)
	}

	return localctx
}

// IElemContext is an interface to support dynamic dispatch.
type IElemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElemContext differentiates from other interfaces.
	IsElemContext()
}

type ElemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElemContext() *ElemContext {
	var p = new(ElemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_elem
	return p
}

func (*ElemContext) IsElemContext() {}

func NewElemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElemContext {
	var p = new(ElemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_elem

	return p
}

func (s *ElemContext) GetParser() antlr.Parser { return s.parser }

func (s *ElemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ElemContext) FuncVars() IFuncVarsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncVarsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncVarsContext)
}

func (s *ElemContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *ElemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitElem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Elem() (localctx IElemContext) {
	localctx = NewElemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, WASTParserRULE_elem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(524)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(503)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(504)
			p.Match(WASTParserT__26)
		}
		p.SetState(506)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME || _la == WASTParserNAT {
			{
				p.SetState(505)
				p.Variable()
			}

		}
		{
			p.SetState(508)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(509)
			p.Match(WASTParserT__30)
		}
		{
			p.SetState(510)
			p.Expr()
		}
		{
			p.SetState(511)
			p.Match(WASTParserT__2)
		}
		{
			p.SetState(512)
			p.FuncVars()
		}
		{
			p.SetState(513)
			p.Match(WASTParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(515)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(516)
			p.Match(WASTParserT__26)
		}
		p.SetState(518)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(517)
				p.Variable()
			}

		}
		{
			p.SetState(520)
			p.Expr()
		}
		{
			p.SetState(521)
			p.FuncVars()
		}
		{
			p.SetState(522)
			p.Match(WASTParserT__2)
		}

	}

	return localctx
}

// IDataContext is an interface to support dynamic dispatch.
type IDataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataContext differentiates from other interfaces.
	IsDataContext()
}

type DataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataContext() *DataContext {
	var p = new(DataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_data
	return p
}

func (*DataContext) IsDataContext() {}

func NewDataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataContext {
	var p = new(DataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_data

	return p
}

func (s *DataContext) GetParser() antlr.Parser { return s.parser }

func (s *DataContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DataContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *DataContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(WASTParserSTRING)
}

func (s *DataContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(WASTParserSTRING, i)
}

func (s *DataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitData(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Data() (localctx IDataContext) {
	localctx = NewDataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, WASTParserRULE_data)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(557)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(526)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(527)
			p.Match(WASTParserT__27)
		}
		p.SetState(529)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME || _la == WASTParserNAT {
			{
				p.SetState(528)
				p.Variable()
			}

		}
		{
			p.SetState(531)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(532)
			p.Match(WASTParserT__30)
		}
		{
			p.SetState(533)
			p.Expr()
		}
		{
			p.SetState(534)
			p.Match(WASTParserT__2)
		}
		p.SetState(538)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == WASTParserSTRING {
			{
				p.SetState(535)
				p.Match(WASTParserSTRING)
			}

			p.SetState(540)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(541)
			p.Match(WASTParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(543)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(544)
			p.Match(WASTParserT__27)
		}
		p.SetState(546)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME || _la == WASTParserNAT {
			{
				p.SetState(545)
				p.Variable()
			}

		}
		{
			p.SetState(548)
			p.Expr()
		}
		p.SetState(552)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == WASTParserSTRING {
			{
				p.SetState(549)
				p.Match(WASTParserSTRING)
			}

			p.SetState(554)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(555)
			p.Match(WASTParserT__2)
		}

	}

	return localctx
}

// IEmbeddedImContext is an interface to support dynamic dispatch.
type IEmbeddedImContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmbeddedImContext differentiates from other interfaces.
	IsEmbeddedImContext()
}

type EmbeddedImContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmbeddedImContext() *EmbeddedImContext {
	var p = new(EmbeddedImContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_embeddedIm
	return p
}

func (*EmbeddedImContext) IsEmbeddedImContext() {}

func NewEmbeddedImContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmbeddedImContext {
	var p = new(EmbeddedImContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_embeddedIm

	return p
}

func (s *EmbeddedImContext) GetParser() antlr.Parser { return s.parser }

func (s *EmbeddedImContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(WASTParserSTRING)
}

func (s *EmbeddedImContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(WASTParserSTRING, i)
}

func (s *EmbeddedImContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmbeddedImContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmbeddedImContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitEmbeddedIm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) EmbeddedIm() (localctx IEmbeddedImContext) {
	localctx = NewEmbeddedImContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, WASTParserRULE_embeddedIm)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(559)
		p.Match(WASTParserT__0)
	}
	{
		p.SetState(560)
		p.Match(WASTParserT__21)
	}
	{
		p.SetState(561)
		p.Match(WASTParserSTRING)
	}
	{
		p.SetState(562)
		p.Match(WASTParserSTRING)
	}
	{
		p.SetState(563)
		p.Match(WASTParserT__2)
	}

	return localctx
}

// IEmbeddedExContext is an interface to support dynamic dispatch.
type IEmbeddedExContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmbeddedExContext differentiates from other interfaces.
	IsEmbeddedExContext()
}

type EmbeddedExContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmbeddedExContext() *EmbeddedExContext {
	var p = new(EmbeddedExContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_embeddedEx
	return p
}

func (*EmbeddedExContext) IsEmbeddedExContext() {}

func NewEmbeddedExContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmbeddedExContext {
	var p = new(EmbeddedExContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_embeddedEx

	return p
}

func (s *EmbeddedExContext) GetParser() antlr.Parser { return s.parser }

func (s *EmbeddedExContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(WASTParserSTRING)
}

func (s *EmbeddedExContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(WASTParserSTRING, i)
}

func (s *EmbeddedExContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmbeddedExContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmbeddedExContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitEmbeddedEx(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) EmbeddedEx() (localctx IEmbeddedExContext) {
	localctx = NewEmbeddedExContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, WASTParserRULE_embeddedEx)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(571)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(565)
				p.Match(WASTParserT__0)
			}
			{
				p.SetState(566)
				p.Match(WASTParserT__28)
			}
			{
				p.SetState(567)
				p.Match(WASTParserSTRING)
			}
			{
				p.SetState(568)
				p.Match(WASTParserT__2)
			}

		}
		p.SetState(573)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeUseContext is an interface to support dynamic dispatch.
type ITypeUseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeUseContext differentiates from other interfaces.
	IsTypeUseContext()
}

type TypeUseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeUseContext() *TypeUseContext {
	var p = new(TypeUseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_typeUse
	return p
}

func (*TypeUseContext) IsTypeUseContext() {}

func NewTypeUseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeUseContext {
	var p = new(TypeUseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_typeUse

	return p
}

func (s *TypeUseContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeUseContext) FuncType() IFuncTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncTypeContext)
}

func (s *TypeUseContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *TypeUseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeUseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeUseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitTypeUse(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) TypeUse() (localctx ITypeUseContext) {
	localctx = NewTypeUseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, WASTParserRULE_typeUse)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(579)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(574)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(575)
			p.Match(WASTParserT__19)
		}
		{
			p.SetState(576)
			p.Variable()
		}
		{
			p.SetState(577)
			p.Match(WASTParserT__2)
		}

	}
	{
		p.SetState(581)
		p.FuncType()
	}

	return localctx
}

// IFuncVarsContext is an interface to support dynamic dispatch.
type IFuncVarsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFuncVarsContext differentiates from other interfaces.
	IsFuncVarsContext()
}

type FuncVarsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncVarsContext() *FuncVarsContext {
	var p = new(FuncVarsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_funcVars
	return p
}

func (*FuncVarsContext) IsFuncVarsContext() {}

func NewFuncVarsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncVarsContext {
	var p = new(FuncVarsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_funcVars

	return p
}

func (s *FuncVarsContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncVarsContext) AllVariable() []IVariableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableContext)(nil)).Elem())
	var tst = make([]IVariableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableContext)
		}
	}

	return tst
}

func (s *FuncVarsContext) Variable(i int) IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *FuncVarsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncVarsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncVarsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitFuncVars(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) FuncVars() (localctx IFuncVarsContext) {
	localctx = NewFuncVarsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, WASTParserRULE_funcVars)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(586)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == WASTParserNAME || _la == WASTParserNAT {
		{
			p.SetState(583)
			p.Variable()
		}

		p.SetState(588)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IValTypeContext is an interface to support dynamic dispatch.
type IValTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValTypeContext differentiates from other interfaces.
	IsValTypeContext()
}

type ValTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValTypeContext() *ValTypeContext {
	var p = new(ValTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_valType
	return p
}

func (*ValTypeContext) IsValTypeContext() {}

func NewValTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValTypeContext {
	var p = new(ValTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_valType

	return p
}

func (s *ValTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ValTypeContext) VAL_TYPE() antlr.TerminalNode {
	return s.GetToken(WASTParserVAL_TYPE, 0)
}

func (s *ValTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitValType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) ValType() (localctx IValTypeContext) {
	localctx = NewValTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, WASTParserRULE_valType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(589)
		p.Match(WASTParserVAL_TYPE)
	}

	return localctx
}

// IBlockTypeContext is an interface to support dynamic dispatch.
type IBlockTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockTypeContext differentiates from other interfaces.
	IsBlockTypeContext()
}

type BlockTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockTypeContext() *BlockTypeContext {
	var p = new(BlockTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_blockType
	return p
}

func (*BlockTypeContext) IsBlockTypeContext() {}

func NewBlockTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockTypeContext {
	var p = new(BlockTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_blockType

	return p
}

func (s *BlockTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockTypeContext) Result() IResultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IResultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IResultContext)
}

func (s *BlockTypeContext) TypeUse() ITypeUseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeUseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeUseContext)
}

func (s *BlockTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitBlockType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) BlockType() (localctx IBlockTypeContext) {
	localctx = NewBlockTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, WASTParserRULE_blockType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(595)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(592)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(591)
				p.Result()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(594)
			p.TypeUse()
		}

	}

	return localctx
}

// IGlobalTypeContext is an interface to support dynamic dispatch.
type IGlobalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobalTypeContext differentiates from other interfaces.
	IsGlobalTypeContext()
}

type GlobalTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalTypeContext() *GlobalTypeContext {
	var p = new(GlobalTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_globalType
	return p
}

func (*GlobalTypeContext) IsGlobalTypeContext() {}

func NewGlobalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalTypeContext {
	var p = new(GlobalTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_globalType

	return p
}

func (s *GlobalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalTypeContext) ValType() IValTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValTypeContext)
}

func (s *GlobalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitGlobalType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) GlobalType() (localctx IGlobalTypeContext) {
	localctx = NewGlobalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, WASTParserRULE_globalType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(603)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WASTParserVAL_TYPE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(597)
			p.ValType()
		}

	case WASTParserT__0:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(598)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(599)
			p.Match(WASTParserT__31)
		}
		{
			p.SetState(600)
			p.ValType()
		}
		{
			p.SetState(601)
			p.Match(WASTParserT__2)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMemoryTypeContext is an interface to support dynamic dispatch.
type IMemoryTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemoryTypeContext differentiates from other interfaces.
	IsMemoryTypeContext()
}

type MemoryTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemoryTypeContext() *MemoryTypeContext {
	var p = new(MemoryTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_memoryType
	return p
}

func (*MemoryTypeContext) IsMemoryTypeContext() {}

func NewMemoryTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemoryTypeContext {
	var p = new(MemoryTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_memoryType

	return p
}

func (s *MemoryTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MemoryTypeContext) Limits() ILimitsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitsContext)
}

func (s *MemoryTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemoryTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemoryTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitMemoryType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) MemoryType() (localctx IMemoryTypeContext) {
	localctx = NewMemoryTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, WASTParserRULE_memoryType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(605)
		p.Limits()
	}

	return localctx
}

// ITableTypeContext is an interface to support dynamic dispatch.
type ITableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableTypeContext differentiates from other interfaces.
	IsTableTypeContext()
}

type TableTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableTypeContext() *TableTypeContext {
	var p = new(TableTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_tableType
	return p
}

func (*TableTypeContext) IsTableTypeContext() {}

func NewTableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableTypeContext {
	var p = new(TableTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_tableType

	return p
}

func (s *TableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TableTypeContext) Limits() ILimitsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitsContext)
}

func (s *TableTypeContext) ElemType() IElemTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElemTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElemTypeContext)
}

func (s *TableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitTableType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) TableType() (localctx ITableTypeContext) {
	localctx = NewTableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, WASTParserRULE_tableType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(607)
		p.Limits()
	}
	{
		p.SetState(608)
		p.ElemType()
	}

	return localctx
}

// IElemTypeContext is an interface to support dynamic dispatch.
type IElemTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElemTypeContext differentiates from other interfaces.
	IsElemTypeContext()
}

type ElemTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElemTypeContext() *ElemTypeContext {
	var p = new(ElemTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_elemType
	return p
}

func (*ElemTypeContext) IsElemTypeContext() {}

func NewElemTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElemTypeContext {
	var p = new(ElemTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_elemType

	return p
}

func (s *ElemTypeContext) GetParser() antlr.Parser { return s.parser }
func (s *ElemTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElemTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElemTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitElemType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) ElemType() (localctx IElemTypeContext) {
	localctx = NewElemTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, WASTParserRULE_elemType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(610)
		p.Match(WASTParserT__32)
	}

	return localctx
}

// ILimitsContext is an interface to support dynamic dispatch.
type ILimitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimitsContext differentiates from other interfaces.
	IsLimitsContext()
}

type LimitsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitsContext() *LimitsContext {
	var p = new(LimitsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_limits
	return p
}

func (*LimitsContext) IsLimitsContext() {}

func NewLimitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitsContext {
	var p = new(LimitsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_limits

	return p
}

func (s *LimitsContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitsContext) AllNat() []INatContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INatContext)(nil)).Elem())
	var tst = make([]INatContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INatContext)
		}
	}

	return tst
}

func (s *LimitsContext) Nat(i int) INatContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INatContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INatContext)
}

func (s *LimitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitLimits(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Limits() (localctx ILimitsContext) {
	localctx = NewLimitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, WASTParserRULE_limits)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(612)
		p.Nat()
	}
	p.SetState(614)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == WASTParserNAT {
		{
			p.SetState(613)
			p.Nat()
		}

	}

	return localctx
}

// IFuncTypeContext is an interface to support dynamic dispatch.
type IFuncTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFuncTypeContext differentiates from other interfaces.
	IsFuncTypeContext()
}

type FuncTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncTypeContext() *FuncTypeContext {
	var p = new(FuncTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_funcType
	return p
}

func (*FuncTypeContext) IsFuncTypeContext() {}

func NewFuncTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncTypeContext {
	var p = new(FuncTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_funcType

	return p
}

func (s *FuncTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncTypeContext) AllParam() []IParamContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParamContext)(nil)).Elem())
	var tst = make([]IParamContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParamContext)
		}
	}

	return tst
}

func (s *FuncTypeContext) Param(i int) IParamContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *FuncTypeContext) AllResult() []IResultContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IResultContext)(nil)).Elem())
	var tst = make([]IResultContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IResultContext)
		}
	}

	return tst
}

func (s *FuncTypeContext) Result(i int) IResultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IResultContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IResultContext)
}

func (s *FuncTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitFuncType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) FuncType() (localctx IFuncTypeContext) {
	localctx = NewFuncTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, WASTParserRULE_funcType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(619)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(616)
				p.Param()
			}

		}
		p.SetState(621)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())
	}
	p.SetState(625)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(622)
				p.Result()
			}

		}
		p.SetState(627)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext())
	}

	return localctx
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_param
	return p
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) AllValType() []IValTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValTypeContext)(nil)).Elem())
	var tst = make([]IValTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValTypeContext)
		}
	}

	return tst
}

func (s *ParamContext) ValType(i int) IValTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValTypeContext)
}

func (s *ParamContext) NAME() antlr.TerminalNode {
	return s.GetToken(WASTParserNAME, 0)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitParam(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, WASTParserRULE_param)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(643)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(628)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(629)
			p.Match(WASTParserT__33)
		}
		p.SetState(633)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == WASTParserVAL_TYPE {
			{
				p.SetState(630)
				p.ValType()
			}

			p.SetState(635)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(636)
			p.Match(WASTParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(637)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(638)
			p.Match(WASTParserT__33)
		}
		{
			p.SetState(639)
			p.Match(WASTParserNAME)
		}
		{
			p.SetState(640)
			p.ValType()
		}
		{
			p.SetState(641)
			p.Match(WASTParserT__2)
		}

	}

	return localctx
}

// IResultContext is an interface to support dynamic dispatch.
type IResultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResultContext differentiates from other interfaces.
	IsResultContext()
}

type ResultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResultContext() *ResultContext {
	var p = new(ResultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_result
	return p
}

func (*ResultContext) IsResultContext() {}

func NewResultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResultContext {
	var p = new(ResultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_result

	return p
}

func (s *ResultContext) GetParser() antlr.Parser { return s.parser }

func (s *ResultContext) AllValType() []IValTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValTypeContext)(nil)).Elem())
	var tst = make([]IValTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValTypeContext)
		}
	}

	return tst
}

func (s *ResultContext) ValType(i int) IValTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValTypeContext)
}

func (s *ResultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitResult(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Result() (localctx IResultContext) {
	localctx = NewResultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, WASTParserRULE_result)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(645)
		p.Match(WASTParserT__0)
	}
	{
		p.SetState(646)
		p.Match(WASTParserT__34)
	}
	p.SetState(650)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == WASTParserVAL_TYPE {
		{
			p.SetState(647)
			p.ValType()
		}

		p.SetState(652)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(653)
		p.Match(WASTParserT__2)
	}

	return localctx
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AllInstr() []IInstrContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInstrContext)(nil)).Elem())
	var tst = make([]IInstrContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInstrContext)
		}
	}

	return tst
}

func (s *ExprContext) Instr(i int) IInstrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstrContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInstrContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, WASTParserRULE_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(658)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == WASTParserT__0 || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(WASTParserT__35-36))|(1<<(WASTParserT__36-36))|(1<<(WASTParserT__37-36))|(1<<(WASTParserT__41-36))|(1<<(WASTParserT__42-36))|(1<<(WASTParserT__43-36))|(1<<(WASTParserT__44-36))|(1<<(WASTParserT__45-36))|(1<<(WASTParserT__46-36))|(1<<(WASTParserT__47-36))|(1<<(WASTParserT__48-36))|(1<<(WASTParserT__49-36))|(1<<(WASTParserT__50-36))|(1<<(WASTParserT__51-36))|(1<<(WASTParserT__52-36))|(1<<(WASTParserVAR_OPS-36))|(1<<(WASTParserMEM_OPS-36))|(1<<(WASTParserCST_OPS-36))|(1<<(WASTParserNUM_OPS-36)))) != 0) {
		{
			p.SetState(655)
			p.Instr()
		}

		p.SetState(660)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInstrContext is an interface to support dynamic dispatch.
type IInstrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstrContext differentiates from other interfaces.
	IsInstrContext()
}

type InstrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstrContext() *InstrContext {
	var p = new(InstrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_instr
	return p
}

func (*InstrContext) IsInstrContext() {}

func NewInstrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstrContext {
	var p = new(InstrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_instr

	return p
}

func (s *InstrContext) GetParser() antlr.Parser { return s.parser }

func (s *InstrContext) PlainInstr() IPlainInstrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPlainInstrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPlainInstrContext)
}

func (s *InstrContext) BlockInstr() IBlockInstrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockInstrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockInstrContext)
}

func (s *InstrContext) FoldedInstr() IFoldedInstrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFoldedInstrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFoldedInstrContext)
}

func (s *InstrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitInstr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Instr() (localctx IInstrContext) {
	localctx = NewInstrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, WASTParserRULE_instr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(664)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WASTParserT__41, WASTParserT__42, WASTParserT__43, WASTParserT__44, WASTParserT__45, WASTParserT__46, WASTParserT__47, WASTParserT__48, WASTParserT__49, WASTParserT__50, WASTParserT__51, WASTParserT__52, WASTParserVAR_OPS, WASTParserMEM_OPS, WASTParserCST_OPS, WASTParserNUM_OPS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(661)
			p.PlainInstr()
		}

	case WASTParserT__35, WASTParserT__36, WASTParserT__37:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(662)
			p.BlockInstr()
		}

	case WASTParserT__0:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(663)
			p.FoldedInstr()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFoldedInstrContext is an interface to support dynamic dispatch.
type IFoldedInstrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// GetLabel returns the label token.
	GetLabel() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// SetLabel sets the label token.
	SetLabel(antlr.Token)

	// IsFoldedInstrContext differentiates from other interfaces.
	IsFoldedInstrContext()
}

type FoldedInstrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
	label  antlr.Token
}

func NewEmptyFoldedInstrContext() *FoldedInstrContext {
	var p = new(FoldedInstrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_foldedInstr
	return p
}

func (*FoldedInstrContext) IsFoldedInstrContext() {}

func NewFoldedInstrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FoldedInstrContext {
	var p = new(FoldedInstrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_foldedInstr

	return p
}

func (s *FoldedInstrContext) GetParser() antlr.Parser { return s.parser }

func (s *FoldedInstrContext) GetOp() antlr.Token { return s.op }

func (s *FoldedInstrContext) GetLabel() antlr.Token { return s.label }

func (s *FoldedInstrContext) SetOp(v antlr.Token) { s.op = v }

func (s *FoldedInstrContext) SetLabel(v antlr.Token) { s.label = v }

func (s *FoldedInstrContext) PlainInstr() IPlainInstrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPlainInstrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPlainInstrContext)
}

func (s *FoldedInstrContext) AllFoldedInstr() []IFoldedInstrContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFoldedInstrContext)(nil)).Elem())
	var tst = make([]IFoldedInstrContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFoldedInstrContext)
		}
	}

	return tst
}

func (s *FoldedInstrContext) FoldedInstr(i int) IFoldedInstrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFoldedInstrContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFoldedInstrContext)
}

func (s *FoldedInstrContext) BlockType() IBlockTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockTypeContext)
}

func (s *FoldedInstrContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *FoldedInstrContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *FoldedInstrContext) NAME() antlr.TerminalNode {
	return s.GetToken(WASTParserNAME, 0)
}

func (s *FoldedInstrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FoldedInstrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FoldedInstrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitFoldedInstr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) FoldedInstr() (localctx IFoldedInstrContext) {
	localctx = NewFoldedInstrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, WASTParserRULE_foldedInstr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(719)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(666)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(667)
			p.PlainInstr()
		}
		p.SetState(671)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == WASTParserT__0 {
			{
				p.SetState(668)
				p.FoldedInstr()
			}

			p.SetState(673)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(674)
			p.Match(WASTParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(676)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(677)

			var _m = p.Match(WASTParserT__35)

			localctx.(*FoldedInstrContext).op = _m
		}
		p.SetState(679)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(678)

				var _m = p.Match(WASTParserNAME)

				localctx.(*FoldedInstrContext).label = _m
			}

		}
		{
			p.SetState(681)
			p.BlockType()
		}
		{
			p.SetState(682)
			p.Expr()
		}
		{
			p.SetState(683)
			p.Match(WASTParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(685)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(686)

			var _m = p.Match(WASTParserT__36)

			localctx.(*FoldedInstrContext).op = _m
		}
		p.SetState(688)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(687)

				var _m = p.Match(WASTParserNAME)

				localctx.(*FoldedInstrContext).label = _m
			}

		}
		{
			p.SetState(690)
			p.BlockType()
		}
		{
			p.SetState(691)
			p.Expr()
		}
		{
			p.SetState(692)
			p.Match(WASTParserT__2)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(694)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(695)

			var _m = p.Match(WASTParserT__37)

			localctx.(*FoldedInstrContext).op = _m
		}
		p.SetState(697)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(696)

				var _m = p.Match(WASTParserNAME)

				localctx.(*FoldedInstrContext).label = _m
			}

		}
		{
			p.SetState(699)
			p.BlockType()
		}
		p.SetState(703)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(700)
					p.FoldedInstr()
				}

			}
			p.SetState(705)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext())
		}
		{
			p.SetState(706)
			p.Match(WASTParserT__0)
		}
		{
			p.SetState(707)
			p.Match(WASTParserT__38)
		}
		{
			p.SetState(708)
			p.Expr()
		}
		{
			p.SetState(709)
			p.Match(WASTParserT__2)
		}
		p.SetState(715)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserT__0 {
			{
				p.SetState(710)
				p.Match(WASTParserT__0)
			}
			{
				p.SetState(711)
				p.Match(WASTParserT__39)
			}
			{
				p.SetState(712)
				p.Expr()
			}
			{
				p.SetState(713)
				p.Match(WASTParserT__2)
			}

		}
		{
			p.SetState(717)
			p.Match(WASTParserT__2)
		}

	}

	return localctx
}

// IBlockInstrContext is an interface to support dynamic dispatch.
type IBlockInstrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// GetLabel returns the label token.
	GetLabel() antlr.Token

	// GetL2 returns the l2 token.
	GetL2() antlr.Token

	// GetL1 returns the l1 token.
	GetL1() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// SetLabel sets the label token.
	SetLabel(antlr.Token)

	// SetL2 sets the l2 token.
	SetL2(antlr.Token)

	// SetL1 sets the l1 token.
	SetL1(antlr.Token)

	// IsBlockInstrContext differentiates from other interfaces.
	IsBlockInstrContext()
}

type BlockInstrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
	label  antlr.Token
	l2     antlr.Token
	l1     antlr.Token
}

func NewEmptyBlockInstrContext() *BlockInstrContext {
	var p = new(BlockInstrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_blockInstr
	return p
}

func (*BlockInstrContext) IsBlockInstrContext() {}

func NewBlockInstrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockInstrContext {
	var p = new(BlockInstrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_blockInstr

	return p
}

func (s *BlockInstrContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockInstrContext) GetOp() antlr.Token { return s.op }

func (s *BlockInstrContext) GetLabel() antlr.Token { return s.label }

func (s *BlockInstrContext) GetL2() antlr.Token { return s.l2 }

func (s *BlockInstrContext) GetL1() antlr.Token { return s.l1 }

func (s *BlockInstrContext) SetOp(v antlr.Token) { s.op = v }

func (s *BlockInstrContext) SetLabel(v antlr.Token) { s.label = v }

func (s *BlockInstrContext) SetL2(v antlr.Token) { s.l2 = v }

func (s *BlockInstrContext) SetL1(v antlr.Token) { s.l1 = v }

func (s *BlockInstrContext) BlockType() IBlockTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockTypeContext)
}

func (s *BlockInstrContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *BlockInstrContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *BlockInstrContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(WASTParserNAME)
}

func (s *BlockInstrContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(WASTParserNAME, i)
}

func (s *BlockInstrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockInstrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockInstrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitBlockInstr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) BlockInstr() (localctx IBlockInstrContext) {
	localctx = NewBlockInstrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, WASTParserRULE_blockInstr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(758)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WASTParserT__35:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(721)

			var _m = p.Match(WASTParserT__35)

			localctx.(*BlockInstrContext).op = _m
		}
		p.SetState(723)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(722)

				var _m = p.Match(WASTParserNAME)

				localctx.(*BlockInstrContext).label = _m
			}

		}
		{
			p.SetState(725)
			p.BlockType()
		}
		{
			p.SetState(726)
			p.Expr()
		}
		{
			p.SetState(727)
			p.Match(WASTParserT__40)
		}
		p.SetState(729)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(728)

				var _m = p.Match(WASTParserNAME)

				localctx.(*BlockInstrContext).l2 = _m
			}

		}

	case WASTParserT__36:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(731)

			var _m = p.Match(WASTParserT__36)

			localctx.(*BlockInstrContext).op = _m
		}
		p.SetState(733)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(732)

				var _m = p.Match(WASTParserNAME)

				localctx.(*BlockInstrContext).label = _m
			}

		}
		{
			p.SetState(735)
			p.BlockType()
		}
		{
			p.SetState(736)
			p.Expr()
		}
		{
			p.SetState(737)
			p.Match(WASTParserT__40)
		}
		p.SetState(739)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(738)

				var _m = p.Match(WASTParserNAME)

				localctx.(*BlockInstrContext).l2 = _m
			}

		}

	case WASTParserT__37:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(741)

			var _m = p.Match(WASTParserT__37)

			localctx.(*BlockInstrContext).op = _m
		}
		p.SetState(743)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserNAME {
			{
				p.SetState(742)

				var _m = p.Match(WASTParserNAME)

				localctx.(*BlockInstrContext).label = _m
			}

		}
		{
			p.SetState(745)
			p.BlockType()
		}
		{
			p.SetState(746)
			p.Expr()
		}
		p.SetState(752)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == WASTParserT__39 {
			{
				p.SetState(747)
				p.Match(WASTParserT__39)
			}
			p.SetState(749)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == WASTParserNAME {
				{
					p.SetState(748)

					var _m = p.Match(WASTParserNAME)

					localctx.(*BlockInstrContext).l1 = _m
				}

			}
			{
				p.SetState(751)
				p.Expr()
			}

		}
		{
			p.SetState(754)
			p.Match(WASTParserT__40)
		}
		p.SetState(756)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(755)

				var _m = p.Match(WASTParserNAME)

				localctx.(*BlockInstrContext).l2 = _m
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPlainInstrContext is an interface to support dynamic dispatch.
type IPlainInstrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsPlainInstrContext differentiates from other interfaces.
	IsPlainInstrContext()
}

type PlainInstrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyPlainInstrContext() *PlainInstrContext {
	var p = new(PlainInstrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_plainInstr
	return p
}

func (*PlainInstrContext) IsPlainInstrContext() {}

func NewPlainInstrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PlainInstrContext {
	var p = new(PlainInstrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_plainInstr

	return p
}

func (s *PlainInstrContext) GetParser() antlr.Parser { return s.parser }

func (s *PlainInstrContext) GetOp() antlr.Token { return s.op }

func (s *PlainInstrContext) SetOp(v antlr.Token) { s.op = v }

func (s *PlainInstrContext) AllVariable() []IVariableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableContext)(nil)).Elem())
	var tst = make([]IVariableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableContext)
		}
	}

	return tst
}

func (s *PlainInstrContext) Variable(i int) IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *PlainInstrContext) TypeUse() ITypeUseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeUseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeUseContext)
}

func (s *PlainInstrContext) VAR_OPS() antlr.TerminalNode {
	return s.GetToken(WASTParserVAR_OPS, 0)
}

func (s *PlainInstrContext) MemArg() IMemArgContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemArgContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMemArgContext)
}

func (s *PlainInstrContext) MEM_OPS() antlr.TerminalNode {
	return s.GetToken(WASTParserMEM_OPS, 0)
}

func (s *PlainInstrContext) NUM_OPS() antlr.TerminalNode {
	return s.GetToken(WASTParserNUM_OPS, 0)
}

func (s *PlainInstrContext) ConstInstr() IConstInstrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstInstrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstInstrContext)
}

func (s *PlainInstrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PlainInstrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PlainInstrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitPlainInstr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) PlainInstr() (localctx IPlainInstrContext) {
	localctx = NewPlainInstrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, WASTParserRULE_plainInstr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(787)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WASTParserT__41:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(760)

			var _m = p.Match(WASTParserT__41)

			localctx.(*PlainInstrContext).op = _m
		}

	case WASTParserT__42:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(761)

			var _m = p.Match(WASTParserT__42)

			localctx.(*PlainInstrContext).op = _m
		}

	case WASTParserT__43:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(762)

			var _m = p.Match(WASTParserT__43)

			localctx.(*PlainInstrContext).op = _m
		}
		{
			p.SetState(763)
			p.Variable()
		}

	case WASTParserT__44:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(764)

			var _m = p.Match(WASTParserT__44)

			localctx.(*PlainInstrContext).op = _m
		}
		{
			p.SetState(765)
			p.Variable()
		}

	case WASTParserT__45:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(766)

			var _m = p.Match(WASTParserT__45)

			localctx.(*PlainInstrContext).op = _m
		}
		p.SetState(768)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(767)
					p.Variable()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(770)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext())
		}

	case WASTParserT__46:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(772)

			var _m = p.Match(WASTParserT__46)

			localctx.(*PlainInstrContext).op = _m
		}

	case WASTParserT__47:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(773)

			var _m = p.Match(WASTParserT__47)

			localctx.(*PlainInstrContext).op = _m
		}
		{
			p.SetState(774)
			p.Variable()
		}

	case WASTParserT__48:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(775)

			var _m = p.Match(WASTParserT__48)

			localctx.(*PlainInstrContext).op = _m
		}
		{
			p.SetState(776)
			p.TypeUse()
		}

	case WASTParserT__49:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(777)

			var _m = p.Match(WASTParserT__49)

			localctx.(*PlainInstrContext).op = _m
		}

	case WASTParserT__50:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(778)

			var _m = p.Match(WASTParserT__50)

			localctx.(*PlainInstrContext).op = _m
		}

	case WASTParserVAR_OPS:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(779)

			var _m = p.Match(WASTParserVAR_OPS)

			localctx.(*PlainInstrContext).op = _m
		}
		{
			p.SetState(780)
			p.Variable()
		}

	case WASTParserMEM_OPS:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(781)

			var _m = p.Match(WASTParserMEM_OPS)

			localctx.(*PlainInstrContext).op = _m
		}
		{
			p.SetState(782)
			p.MemArg()
		}

	case WASTParserT__51:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(783)

			var _m = p.Match(WASTParserT__51)

			localctx.(*PlainInstrContext).op = _m
		}

	case WASTParserT__52:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(784)

			var _m = p.Match(WASTParserT__52)

			localctx.(*PlainInstrContext).op = _m
		}

	case WASTParserNUM_OPS:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(785)

			var _m = p.Match(WASTParserNUM_OPS)

			localctx.(*PlainInstrContext).op = _m
		}

	case WASTParserCST_OPS:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(786)
			p.ConstInstr()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConstInstrContext is an interface to support dynamic dispatch.
type IConstInstrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsConstInstrContext differentiates from other interfaces.
	IsConstInstrContext()
}

type ConstInstrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyConstInstrContext() *ConstInstrContext {
	var p = new(ConstInstrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_constInstr
	return p
}

func (*ConstInstrContext) IsConstInstrContext() {}

func NewConstInstrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstInstrContext {
	var p = new(ConstInstrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_constInstr

	return p
}

func (s *ConstInstrContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstInstrContext) GetOp() antlr.Token { return s.op }

func (s *ConstInstrContext) SetOp(v antlr.Token) { s.op = v }

func (s *ConstInstrContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ConstInstrContext) CST_OPS() antlr.TerminalNode {
	return s.GetToken(WASTParserCST_OPS, 0)
}

func (s *ConstInstrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstInstrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstInstrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitConstInstr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) ConstInstr() (localctx IConstInstrContext) {
	localctx = NewConstInstrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, WASTParserRULE_constInstr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(789)

		var _m = p.Match(WASTParserCST_OPS)

		localctx.(*ConstInstrContext).op = _m
	}
	{
		p.SetState(790)
		p.Value()
	}

	return localctx
}

// IMemArgContext is an interface to support dynamic dispatch.
type IMemArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOffset returns the offset rule contexts.
	GetOffset() INatContext

	// GetAlign returns the align rule contexts.
	GetAlign() INatContext

	// SetOffset sets the offset rule contexts.
	SetOffset(INatContext)

	// SetAlign sets the align rule contexts.
	SetAlign(INatContext)

	// IsMemArgContext differentiates from other interfaces.
	IsMemArgContext()
}

type MemArgContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	offset INatContext
	align  INatContext
}

func NewEmptyMemArgContext() *MemArgContext {
	var p = new(MemArgContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_memArg
	return p
}

func (*MemArgContext) IsMemArgContext() {}

func NewMemArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemArgContext {
	var p = new(MemArgContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_memArg

	return p
}

func (s *MemArgContext) GetParser() antlr.Parser { return s.parser }

func (s *MemArgContext) GetOffset() INatContext { return s.offset }

func (s *MemArgContext) GetAlign() INatContext { return s.align }

func (s *MemArgContext) SetOffset(v INatContext) { s.offset = v }

func (s *MemArgContext) SetAlign(v INatContext) { s.align = v }

func (s *MemArgContext) AllNat() []INatContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INatContext)(nil)).Elem())
	var tst = make([]INatContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INatContext)
		}
	}

	return tst
}

func (s *MemArgContext) Nat(i int) INatContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INatContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INatContext)
}

func (s *MemArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitMemArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) MemArg() (localctx IMemArgContext) {
	localctx = NewMemArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, WASTParserRULE_memArg)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(795)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == WASTParserT__30 {
		{
			p.SetState(792)
			p.Match(WASTParserT__30)
		}
		{
			p.SetState(793)
			p.Match(WASTParserT__53)
		}
		{
			p.SetState(794)

			var _x = p.Nat()

			localctx.(*MemArgContext).offset = _x
		}

	}
	p.SetState(800)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == WASTParserT__54 {
		{
			p.SetState(797)
			p.Match(WASTParserT__54)
		}
		{
			p.SetState(798)
			p.Match(WASTParserT__53)
		}
		{
			p.SetState(799)

			var _x = p.Nat()

			localctx.(*MemArgContext).align = _x
		}

	}

	return localctx
}

// INatContext is an interface to support dynamic dispatch.
type INatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNatContext differentiates from other interfaces.
	IsNatContext()
}

type NatContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNatContext() *NatContext {
	var p = new(NatContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_nat
	return p
}

func (*NatContext) IsNatContext() {}

func NewNatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NatContext {
	var p = new(NatContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_nat

	return p
}

func (s *NatContext) GetParser() antlr.Parser { return s.parser }

func (s *NatContext) NAT() antlr.TerminalNode {
	return s.GetToken(WASTParserNAT, 0)
}

func (s *NatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitNat(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Nat() (localctx INatContext) {
	localctx = NewNatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, WASTParserRULE_nat)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(802)
		p.Match(WASTParserNAT)
	}

	return localctx
}

// IValueContext is an interface to support dynamic dispatch.
type IValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueContext differentiates from other interfaces.
	IsValueContext()
}

type ValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueContext() *ValueContext {
	var p = new(ValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_value
	return p
}

func (*ValueContext) IsValueContext() {}

func NewValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueContext {
	var p = new(ValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_value

	return p
}

func (s *ValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueContext) NAT() antlr.TerminalNode {
	return s.GetToken(WASTParserNAT, 0)
}

func (s *ValueContext) INT() antlr.TerminalNode {
	return s.GetToken(WASTParserINT, 0)
}

func (s *ValueContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(WASTParserFLOAT, 0)
}

func (s *ValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Value() (localctx IValueContext) {
	localctx = NewValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, WASTParserRULE_value)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(804)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(WASTParserFLOAT-59))|(1<<(WASTParserNAT-59))|(1<<(WASTParserINT-59)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WASTParserRULE_variable
	return p
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WASTParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) NAT() antlr.TerminalNode {
	return s.GetToken(WASTParserNAT, 0)
}

func (s *VariableContext) NAME() antlr.TerminalNode {
	return s.GetToken(WASTParserNAME, 0)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case WASTVisitor:
		return t.VisitVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *WASTParser) Variable() (localctx IVariableContext) {
	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, WASTParserRULE_variable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(806)
		_la = p.GetTokenStream().LA(1)

		if !(_la == WASTParserNAME || _la == WASTParserNAT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}
